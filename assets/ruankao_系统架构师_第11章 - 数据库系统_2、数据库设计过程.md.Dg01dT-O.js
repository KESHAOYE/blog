import{_ as r,c as t,ag as i,j as a,o as h}from"./chunks/framework.BxW8Wou5.js";const o="/blog/picture/%E8%BD%AF%E8%80%83/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png",e="/blog/picture/%E8%BD%AF%E8%80%83/ER%E5%9B%BE.png",m=JSON.parse('{"title":"2、数据库设计过程","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/系统架构师/第11章 - 数据库系统/2、数据库设计过程.md","filePath":"ruankao/系统架构师/第11章 - 数据库系统/2、数据库设计过程.md","lastUpdated":1748002092000}'),n={name:"ruankao/系统架构师/第11章 - 数据库系统/2、数据库设计过程.md"};function u(d,l,s,c,b,q){return h(),t("div",null,l[0]||(l[0]=[i('<h1 id="_2、数据库设计过程" tabindex="-1">2、数据库设计过程 <a class="header-anchor" href="#_2、数据库设计过程" aria-label="Permalink to &quot;2、数据库设计过程&quot;">​</a></h1><img src="'+o+'"><h2 id="需求分析" tabindex="-1">需求分析 <a class="header-anchor" href="#需求分析" aria-label="Permalink to &quot;需求分析&quot;">​</a></h2><ul><li>参照数据相关要求</li></ul><h3 id="产物" tabindex="-1">产物 <a class="header-anchor" href="#产物" aria-label="Permalink to &quot;产物&quot;">​</a></h3><ul><li>数据流图</li><li>数据字典</li><li>需求说明书</li></ul><h2 id="概念结构设计" tabindex="-1">概念结构设计 <a class="header-anchor" href="#概念结构设计" aria-label="Permalink to &quot;概念结构设计&quot;">​</a></h2><p>根据需求阶段的产物</p><h3 id="阶段" tabindex="-1">阶段 <a class="header-anchor" href="#阶段" aria-label="Permalink to &quot;阶段&quot;">​</a></h3><h4 id="抽象数据" tabindex="-1">抽象数据 <a class="header-anchor" href="#抽象数据" aria-label="Permalink to &quot;抽象数据&quot;">​</a></h4><h4 id="设计局部-er-模型" tabindex="-1">设计局部 ER 模型 <a class="header-anchor" href="#设计局部-er-模型" aria-label="Permalink to &quot;设计局部 ER 模型&quot;">​</a></h4><h4 id="合并局部模型-集成-消除冲突" tabindex="-1">合并局部模型（集成），消除冲突 <a class="header-anchor" href="#合并局部模型-集成-消除冲突" aria-label="Permalink to &quot;合并局部模型（集成），消除冲突&quot;">​</a></h4><ul><li>多个局部 ER 图一次集成</li><li>逐步集成，用累加的方式一次集成两个局部 ER 图</li></ul><h5 id="冲突及解决方法" tabindex="-1">冲突及解决方法 <a class="header-anchor" href="#冲突及解决方法" aria-label="Permalink to &quot;冲突及解决方法&quot;">​</a></h5><ul><li>属性冲突：包括属性域冲突和属性取值冲突</li><li>命名冲突：包括同名异义和异名同义</li><li>结构冲突：包括同一对象在不同应用中具有不同的抽象，以及同一实体在不同局部 ER 图中所包含的属性个数和属性排列次序不完全相同</li></ul><h4 id="重构优化-消除冗余" tabindex="-1">重构优化，消除冗余 <a class="header-anchor" href="#重构优化-消除冗余" aria-label="Permalink to &quot;重构优化，消除冗余&quot;">​</a></h4><h3 id="产物-1" tabindex="-1">产物 <a class="header-anchor" href="#产物-1" aria-label="Permalink to &quot;产物&quot;">​</a></h3><img src="'+e+'"><ul><li>ER 图（实体联系图）</li></ul><h4 id="er-图" tabindex="-1">ER 图 <a class="header-anchor" href="#er-图" aria-label="Permalink to &quot;ER 图&quot;">​</a></h4><img src="'+e+'"><h5 id="联系" tabindex="-1">联系 <a class="header-anchor" href="#联系" aria-label="Permalink to &quot;联系&quot;">​</a></h5><ul><li>一对一（1：1）</li><li>一对多（1：n）</li><li>多对多（n: m）</li></ul><h2 id="逻辑结构设计" tabindex="-1">逻辑结构设计 <a class="header-anchor" href="#逻辑结构设计" aria-label="Permalink to &quot;逻辑结构设计&quot;">​</a></h2><p>考虑 ER 图</p><h3 id="产物-2" tabindex="-1">产物 <a class="header-anchor" href="#产物-2" aria-label="Permalink to &quot;产物&quot;">​</a></h3><h4 id="关系模式-参考需求从-er-图转换而来" tabindex="-1">关系模式（参考需求从 ER 图转换而来） <a class="header-anchor" href="#关系模式-参考需求从-er-图转换而来" aria-label="Permalink to &quot;关系模式（参考需求从 ER 图转换而来）&quot;">​</a></h4><p>是一种数据模型，数据模型三要素：数据结构、数据操作、数据的约束条件</p><h5 id="样式及组成" tabindex="-1">样式及组成 <a class="header-anchor" href="#样式及组成" aria-label="Permalink to &quot;样式及组成&quot;">​</a></h5>',29),a("ul",null,[a("li",null,[a("p",null,"形式 1： 学生（学号、姓名、年龄、班级编号）")]),a("li",{"学号-姓名，学号-年龄，学号-班级编号":""},[a("p",null,"形式 2： 学生（U、F） U={学号、姓名、年龄、班级编号} F=")]),a("li",null,[a("p",null,"目或度：关系模式中属性的个数")]),a("li",null,[a("p",null,"候选码（候选键）：唯一标识元组，没有冗余")]),a("li",null,[a("p",null,"主码（主键）：候选键中任选一个")]),a("li",null,[a("p",null,"主属性和非主属性：组成候选码的属性就是主属性，其它就是非主属性")]),a("li",null,[a("p",null,"外码（外键）")]),a("li",null,[a("p",null,"全码：关系模式的所有属性组是这个关系的候选码")])],-1),i('<p><strong>派生属性</strong>：能推算出的属性就是派生属性，比如出生日期可以推算年龄</p><h5 id="模型" tabindex="-1">模型 <a class="header-anchor" href="#模型" aria-label="Permalink to &quot;模型&quot;">​</a></h5><ul><li>层次模型</li><li>网状模型</li><li>面向对象模型</li><li><strong>关系模型</strong>：学生（学号、姓名、年龄、班级编号）</li></ul><h3 id="阶段-1" tabindex="-1">阶段 <a class="header-anchor" href="#阶段-1" aria-label="Permalink to &quot;阶段&quot;">​</a></h3><h4 id="转化为关系模型" tabindex="-1">转化为关系模型 <a class="header-anchor" href="#转化为关系模型" aria-label="Permalink to &quot;转化为关系模型&quot;">​</a></h4><ul><li>实体向关系模式转换</li><li>联系向关系模式转换</li></ul><h4 id="关系规范化" tabindex="-1">关系规范化 <a class="header-anchor" href="#关系规范化" aria-label="Permalink to &quot;关系规范化&quot;">​</a></h4><h5 id="非规范化的问题" tabindex="-1">非规范化的问题 <a class="header-anchor" href="#非规范化的问题" aria-label="Permalink to &quot;非规范化的问题&quot;">​</a></h5><ul><li>数据冗余</li><li>更新异常（修改操作一致性问题）</li><li>插入异常</li><li>删除异常</li></ul><h5 id="基本概念" tabindex="-1">基本概念 <a class="header-anchor" href="#基本概念" aria-label="Permalink to &quot;基本概念&quot;">​</a></h5><h6 id="函数依赖" tabindex="-1">函数依赖 <a class="header-anchor" href="#函数依赖" aria-label="Permalink to &quot;函数依赖&quot;">​</a></h6><p>学号 -&gt; 系号 系号 -&gt; 系名</p><p><strong>左边可以唯一确定右边，右边不能唯一确定左边</strong></p><h6 id="候选键" tabindex="-1">候选键 <a class="header-anchor" href="#候选键" aria-label="Permalink to &quot;候选键&quot;">​</a></h6><p>唯一标识元组，且无冗余</p><p>使用图示法找候选键</p><p>将关系模式的函数依赖用“有向图”表示 找到入度为 0 的属性，并以该属性集合为起点，尝试遍历有向图，如果能正常遍历图中所有节点，则该属性集即为关系模式的候选键 若入度为 0 的属性集不能遍历图中所有节点，则需要尝试性的将一些中间节点（有入度有出度）并入入度为 0 的属性集中，直至该集合能遍历所有节点，集合为候选键</p><h6 id="公理系统-armstrong" tabindex="-1">公理系统 Armstrong <a class="header-anchor" href="#公理系统-armstrong" aria-label="Permalink to &quot;公理系统 Armstrong&quot;">​</a></h6><p>关系模式 R&lt;U,F&gt;来说有以下推理规则：</p><ul><li>A1.自反律：若 Y 属于 X 属于 U，推出 X-&gt;Y</li><li>A2.增广律：若 Z 属于 U 且 X-&gt;Y，推出 XZ-&gt;YZ</li><li>A3.传递律：若 X-&gt;Y 且 Y-&gt;Z，推出 X-&gt;Z</li></ul><p>根据 A1、A2、A3，可以推导出以下结论：</p><ul><li>合并规则：由 X-&gt;Y 和 Y-&gt;Z，推出 X-&gt;YZ (A2、A3)</li><li>伪传递规则：由 X-&gt;Y，WY-&gt;Z，推出 Xw-&gt;Z (A2、A3)</li><li>分解规则：由 X-&gt;Y 和 Z 属于 Y，推出 X-&gt;Z (A1、A3)</li></ul><h6 id="范式判断" tabindex="-1">范式判断 <a class="header-anchor" href="#范式判断" aria-label="Permalink to &quot;范式判断&quot;">​</a></h6><p>级别越高越能解决插入异常、删除异常、数据冗余的问题</p><ul><li><p>1NF：属性值都是不可再分的原子值</p><p>简单属性和复杂属性，单值属性和多值属性，NULL 属性，派生属性</p></li><li><p>2NF：必须满足第一范式，且每个非主属性完全依赖主键</p></li><li><p>3NF：必须满足第二范式，且没有非主属性传递依赖于主键</p></li><li><p>BCNF：消除主属性对候选键的部分和传递依赖</p></li></ul><h4 id="模式优化" tabindex="-1">模式优化 <a class="header-anchor" href="#模式优化" aria-label="Permalink to &quot;模式优化&quot;">​</a></h4><h4 id="设计用户子模式" tabindex="-1">设计用户子模式 <a class="header-anchor" href="#设计用户子模式" aria-label="Permalink to &quot;设计用户子模式&quot;">​</a></h4><h4 id="确定完整性约束" tabindex="-1">确定完整性约束 <a class="header-anchor" href="#确定完整性约束" aria-label="Permalink to &quot;确定完整性约束&quot;">​</a></h4><ul><li>实体完整性约束：规定基本关系的主属性不能取空值（唯一且非空）</li><li>参照完整性约束：关系与关系间的引用，其他关系的主键或空值（）</li><li>用户自定义完整性约束：应用环境决定</li><li>触发器</li></ul><h4 id="用户视图的确定" tabindex="-1">用户视图的确定 <a class="header-anchor" href="#用户视图的确定" aria-label="Permalink to &quot;用户视图的确定&quot;">​</a></h4><ul><li>根据数据流图确定处理过程使用的视图</li><li>根据用户类别确定不同用户使用的视图</li></ul><h3 id="转换原则" tabindex="-1">转换原则 <a class="header-anchor" href="#转换原则" aria-label="Permalink to &quot;转换原则&quot;">​</a></h3><ul><li>一个实体性必须转换为一个关系模式</li><li>联系转关系模式：一对一、一对多（并入实体）；一对一、一对多、多对多（独立关系）</li></ul><h4 id="一对一转换" tabindex="-1">一对一转换 <a class="header-anchor" href="#一对一转换" aria-label="Permalink to &quot;一对一转换&quot;">​</a></h4><ul><li>独立的关系模式：并入两端主键及联系自身属性（主键：任一端主键）</li><li>归并（任意一端）：并入另一端主键及联系自身属性（主键：保持不变）</li></ul><h4 id="一对多转换" tabindex="-1">一对多转换 <a class="header-anchor" href="#一对多转换" aria-label="Permalink to &quot;一对多转换&quot;">​</a></h4><ul><li>独立的关系模式：并入两端主键及联系自身属性（主键：多端主键）</li><li>归并（多端）：并入另一端主键及联系自身属性（主键：保持不变）</li></ul><h4 id="多对多转换" tabindex="-1">多对多转换 <a class="header-anchor" href="#多对多转换" aria-label="Permalink to &quot;多对多转换&quot;">​</a></h4><ul><li>独立的关系模式：并入两端主键及联系自身属性（主键：两端主键的组合键）</li></ul><h2 id="物理设计" tabindex="-1">物理设计 <a class="header-anchor" href="#物理设计" aria-label="Permalink to &quot;物理设计&quot;">​</a></h2><p>完成对数据库分布形式、存储形式、访问形式的设计 涉及到索引等，是物理设计阶段</p>',41)]))}const _=r(n,[["render",u]]);export{m as __pageData,_ as default};

import{_ as s,c as i,ag as e,o as l}from"./chunks/framework.BxW8Wou5.js";const c=JSON.parse('{"title":"2. webpack中loader和plugin的区别","description":"","frontmatter":{},"headers":[],"relativePath":"interview/工程化/2. webpack相关.md","filePath":"interview/工程化/2. webpack相关.md","lastUpdated":1705938767000}'),n={name:"interview/工程化/2. webpack相关.md"};function t(p,a,h,k,r,o){return l(),i("div",null,a[0]||(a[0]=[e(`<h1 id="_2-webpack中loader和plugin的区别" tabindex="-1">2. webpack中loader和plugin的区别 <a class="header-anchor" href="#_2-webpack中loader和plugin的区别" aria-label="Permalink to &quot;2. webpack中loader和plugin的区别&quot;">​</a></h1><h2 id="什么是webpack" tabindex="-1">什么是webpack <a class="header-anchor" href="#什么是webpack" aria-label="Permalink to &quot;什么是webpack&quot;">​</a></h2><p>webpack是一个用于现代Javascript应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。（<strong>bundle为输出的文件</strong>）</p><p><strong>webpack由nodejs编写，本身功能不多，只能用于处理JS</strong></p><h2 id="核心概念" tabindex="-1">核心概念 <a class="header-anchor" href="#核心概念" aria-label="Permalink to &quot;核心概念&quot;">​</a></h2><ul><li>entry： 入口，指示 Webpack 从哪个文件开始打包</li><li>output： 输出，告诉 Webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。</li><li>mode： 模式，告知webpack使用相应模式的内置优化</li><li>loader：模块代码转换器，webpack 本身只能处理 js、json 等资源，其他资源需要借助 loader，Webpack 才能解析</li><li>plugin： 扩展插件。在webpack运行的生命周期中会广播出许多事件，plugin可以监听这些事件，在合适的时机通过webpack提供的api改变输出结果。常见的有：打包优化，资源管理，注入环境变量。</li><li>chunk：代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。</li></ul><h3 id="loader-加载器" tabindex="-1">loader（加载器） <a class="header-anchor" href="#loader-加载器" aria-label="Permalink to &quot;loader（加载器）&quot;">​</a></h3><p>webpack提供了一种处理多种文件格式的机制，便是Loader。<strong>我们可以将Loader看成一个转换器</strong>，它可以将某种格式文件转换成webpack支持打包的模块。</p><p>webpack中一切皆可模块化。js、css、less、ts、图片等都是模块，不同模块的加载是通过模块加载器来统一管理的，当我们需要使用不同的 Loader 来解析不同类型的文件时，我们可以在module.rules字段下配置相关规则。<a href="./../../frontend-basic/工程化/webpack/基础/5.处理图片资源.html">例如webpack处理图片资源</a></p><h4 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h4><ul><li>loader本质上是一个函数</li><li>loader支持链式调用，webpack打包时是按照数组从后往前的顺序将资源交给loader处理的。</li><li>支持同步和异步</li></ul><h4 id="代码结构" tabindex="-1">代码结构 <a class="header-anchor" href="#代码结构" aria-label="Permalink to &quot;代码结构&quot;">​</a></h4><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// source：资源输入，对于第一个执行的 loader 为资源文件的内容；后续执行的 loader 则为前一个 loader 的执行结果</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// sourceMap: 可选参数，代码的 sourcemap 结构</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// data: 可选参数，其它需要在 Loader 链中传递的信息，比如 posthtml/posthtml-loader 就会通过这个参数传递参数的 AST 对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> loaderUtils</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;loader-utils&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">sourceMap</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">data</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 获取到用户给当前 Loader 传入的 options</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loaderUtils.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // TODO： 此处为转换source的逻辑</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h4 id="常用的loader" tabindex="-1">常用的loader <a class="header-anchor" href="#常用的loader" aria-label="Permalink to &quot;常用的loader&quot;">​</a></h4><ul><li>babel-loader</li><li>ts-loader</li><li>markdown-loader ...</li></ul><h3 id="plugin" tabindex="-1">plugin <a class="header-anchor" href="#plugin" aria-label="Permalink to &quot;plugin&quot;">​</a></h3><blockquote><p>Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。</p></blockquote><blockquote><p>Webpack 通过 Tapable 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。</p></blockquote>`,18)]))}const u=s(n,[["render",t]]);export{c as __pageData,u as default};

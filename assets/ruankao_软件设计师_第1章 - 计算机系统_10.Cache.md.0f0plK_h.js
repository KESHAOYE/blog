import{_ as e,c as t,ag as r,o as h}from"./chunks/framework.BxW8Wou5.js";const _=JSON.parse('{"title":"10、cache 高速缓存","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/软件设计师/第1章 - 计算机系统/10.Cache.md","filePath":"ruankao/软件设计师/第1章 - 计算机系统/10.Cache.md","lastUpdated":1760412047000}'),o={name:"ruankao/软件设计师/第1章 - 计算机系统/10.Cache.md"};function c(l,a,i,n,s,d){return h(),t("div",null,a[0]||(a[0]=[r('<h1 id="_10、cache-高速缓存" tabindex="-1">10、cache 高速缓存 <a class="header-anchor" href="#_10、cache-高速缓存" aria-label="Permalink to &quot;10、cache 高速缓存&quot;">​</a></h1><p>用来存放当前最活跃的程序和数据，<strong>位于 CPU 和主存之间</strong>，容量不大，速度比主存快 5-10 倍，<strong>对程序员透明</strong>，映射是由硬件自动完成的。</p><p><strong>存放主存的部分拷贝信息</strong></p><h2 id="控制部分" tabindex="-1">控制部分 <a class="header-anchor" href="#控制部分" aria-label="Permalink to &quot;控制部分&quot;">​</a></h2><p>判断 CPU 要访问的信息在 cache 中是否存在，存在的话则为命中直接访问，不存在的话则没有命中，从主存读取后存入 Cache</p><h2 id="替换算法" tabindex="-1">替换算法 <a class="header-anchor" href="#替换算法" aria-label="Permalink to &quot;替换算法&quot;">​</a></h2><p>Cache 的容量越大，命中率越高（非线性）。但是 Cache 的成本增加，命中时间增加。</p><ul><li>随机替换算法：用随机数发生器产生一个要替换的符号，将该块替换出去。</li><li>先进先出算法：最先进入 Cache 的块，先被替换出去。</li><li>近期最少使用算法：将近期最少使用的 Cache 中的信息块替换出去</li><li>优化替换算法：先执行一次程序，统计 Cache 的替换情况</li></ul><h2 id="地址映像" tabindex="-1">地址映像 <a class="header-anchor" href="#地址映像" aria-label="Permalink to &quot;地址映像&quot;">​</a></h2><p>CPU 工作时送出的是主存单元的地址，应从 Cache 存储器中读/写信息。这就需要将主存地址转换成 Cache 存储器地址，这就是地址映像</p><h3 id="直接映像" tabindex="-1">直接映像 <a class="header-anchor" href="#直接映像" aria-label="Permalink to &quot;直接映像&quot;">​</a></h3><p>主存的块和 Cache 块的对应关系是固定的，冲突大</p><h3 id="全相联映像" tabindex="-1">全相联映像 <a class="header-anchor" href="#全相联映像" aria-label="Permalink to &quot;全相联映像&quot;">​</a></h3><p>允许主存的任一块可以调入 Cache 存储器的任何一个块的空间中。冲突小</p><h3 id="组相联映像" tabindex="-1">组相联映像 <a class="header-anchor" href="#组相联映像" aria-label="Permalink to &quot;组相联映像&quot;">​</a></h3><p>组与组之间映射，冲突较少</p>',16)]))}const u=e(o,[["render",c]]);export{_ as __pageData,u as default};

import{_ as a,c as l,ag as e,o as h}from"./chunks/framework.BxW8Wou5.js";const i="/blog/picture/%E8%BD%AF%E8%80%83/%E7%A3%81%E7%9B%98%E5%9F%BA%E6%9C%AC.png",r="/blog/picture/%E8%BD%AF%E8%80%83/%E7%A3%81%E7%9B%98%E7%A3%81%E5%A4%B4.png",d="/blog/picture/%E8%BD%AF%E8%80%83/%E7%A7%BB%E8%87%82%E7%AE%97%E6%B3%95-%E5%85%88%E6%9D%A5%E5%85%88%E6%9C%8D%E5%8A%A1.png",s="/blog/picture/%E8%BD%AF%E8%80%83/%E7%A7%BB%E8%87%82%E7%AE%97%E6%B3%95-%E6%9C%80%E7%9F%AD%E5%AF%BB%E9%81%93%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88.png",_=JSON.parse('{"title":"5、磁盘管理","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/系统架构师/第8章 - 计算机基础知识/1、计算机系统组成/5、磁盘管理.md","filePath":"ruankao/系统架构师/第8章 - 计算机基础知识/1、计算机系统组成/5、磁盘管理.md","lastUpdated":1748002092000}'),o={name:"ruankao/系统架构师/第8章 - 计算机基础知识/1、计算机系统组成/5、磁盘管理.md"};function n(c,t,m,u,p,b){return h(),l("div",null,t[0]||(t[0]=[e('<h1 id="_5、磁盘管理" tabindex="-1">5、磁盘管理 <a class="header-anchor" href="#_5、磁盘管理" aria-label="Permalink to &quot;5、磁盘管理&quot;">​</a></h1><img src="'+i+'"><p>绿色的是磁道，等分为扇区，有多个盘面，最外圈是 0 号磁道</p><img src="'+r+'"><p>每个盘面有一个磁头，所有磁头连接主杆，所有磁头一起移动，固定方向持续移动</p><h2 id="时间" tabindex="-1">时间 <a class="header-anchor" href="#时间" aria-label="Permalink to &quot;时间&quot;">​</a></h2><p>读取磁盘数据的时间包括：</p><ul><li>找磁道时间（寻道时间）</li><li>找块（扇区）时间，即旋转延迟时间（等待时间）</li><li>传输时间（看题目有没有定义）</li></ul><p>存取时间 = 寻道时间（磁头移动到磁道所需时间） + 等待时间（等待读写的扇区转到磁头下方所用的时间）</p><h2 id="磁盘平均存取时间例题" tabindex="-1">磁盘平均存取时间例题 <a class="header-anchor" href="#磁盘平均存取时间例题" aria-label="Permalink to &quot;磁盘平均存取时间例题&quot;">​</a></h2><p>某磁盘磁头从一个磁道移至另一个磁道需要 10ms。文件在磁盘上非连续存放逻辑上相邻数据块的平均移动距离为 10 个磁道，每块的旋转延迟时间及传输时间分别为 100ms 和 2ms，则读取一个 100 块的文件需要()ms 时间。</p><ul><li>寻道时间/块：10ms * 10 个磁道 = 100ms</li><li>旋转延迟时间/块：100ms</li><li>传输时间/块：2ms</li></ul><p>得出读取一块的平均时间是： 寻道时间/块 + 旋转延迟时间/块 + 传输时间/块 = 100ms + 100ms + 2ms = 202ms</p><p>所以读取 100 块的平均时间是： 202ms * 100 = 20200ms</p><h2 id="磁盘优化分布存取时间例题" tabindex="-1">磁盘优化分布存取时间例题 <a class="header-anchor" href="#磁盘优化分布存取时间例题" aria-label="Permalink to &quot;磁盘优化分布存取时间例题&quot;">​</a></h2><p>假设某磁盘的每个磁道划分成 11 个物理块，每块存放 1 个逻辑记录。逻辑记录 R。，R1，···，Rg，R1o 存放在同一个磁道上，记录的存放顺序如下表所示:</p><table tabindex="0"><thead><tr><th>物理块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>逻辑记录</td><td>R0</td><td>R1</td><td>R2</td><td>R3</td><td>R4</td><td>R5</td><td>R6</td><td>R7</td><td>R8</td><td>R9</td><td>R10</td></tr></tbody></table><p>如果磁盘的旋转周期为 33ms，磁头当前处在 R。的开始处。若系统使用单缓冲区顺序处理这些记录，每个记录处理时间为 3ms，则处理这 11 个记录的最长时间为();若对信息存储进行优化分布后，处理 11 个记录的最少时间为()。</p><h3 id="第一问" tabindex="-1">第一问 <a class="header-anchor" href="#第一问" aria-label="Permalink to &quot;第一问&quot;">​</a></h3><ul><li>转一圈 33ms，有 11 个物理块，读取一个信息的记录是 3ms</li><li>单缓冲区说明缓冲区只能有一个数据</li><li>R0：没有寻道时间（顺序存放），没有旋转延迟时间（磁头在起始位置），需要 3ms 存入缓冲区时间，3ms 读取信息时间</li><li>R1 - R10：R0 处理完以后磁盘不会停止，3ms 以后刚好错过 R1，旋转延迟时间为 30ms 需要 3ms 存入缓冲区时间，3ms 读取信息时间</li><li>一共 6 + （30 + 3 + 3）* 10 = 366ms</li></ul><h3 id="第二问" tabindex="-1">第二问 <a class="header-anchor" href="#第二问" aria-label="Permalink to &quot;第二问&quot;">​</a></h3><ul><li>优化分布，即自己选择存放位置</li></ul><table tabindex="0"><thead><tr><th>物理块</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th></tr></thead><tbody><tr><td>逻辑记录</td><td>R0</td><td>R6</td><td>R1</td><td>R7</td><td>R2</td><td>R8</td><td>R3</td><td>R9</td><td>R4</td><td>R10</td><td>R5</td></tr></tbody></table><ul><li>相当于转了两圈，33ms * 2 = 66ms</li></ul><h2 id="xxx" tabindex="-1">xxx <a class="header-anchor" href="#xxx" aria-label="Permalink to &quot;xxx&quot;">​</a></h2><p>某计算机系统输入/输出采用双缓冲工作方式，其工作过程如下图所示，假设磁盘块与缓冲区大小相同，每个盘块读入缓冲区的时间 T 为 10μs，由缓冲区送至用户区的时间 M 为 6μs，系统对每个磁盘块数据的处理时间 C 为 2μs。若用户需要将大小为 10 个磁盘块的 Doc1 文件逐块从磁盘读入缓冲区，并送至用户区进行处理，那么采用双缓冲需要花费的时间为（问题 1）μs，比使用单缓冲节约了（问题 2）μs 时间。</p><h3 id="双缓冲" tabindex="-1">双缓冲 <a class="header-anchor" href="#双缓冲" aria-label="Permalink to &quot;双缓冲&quot;">​</a></h3><ul><li>双缓冲情况下，读入（T）和传输 + 处理（M+C）可以并行（流水线）</li><li>第一个磁盘块没有并行可能 10 + 6 + 2 = 18μs</li><li>第二块开始，一边读下一个块（10），一边处理上一个块（6 + 2），瓶颈为读入 T，每个块新增时间为 10</li><li>18 + 9 * 10 = 108μs</li></ul><h3 id="单缓冲" tabindex="-1">单缓冲 <a class="header-anchor" href="#单缓冲" aria-label="Permalink to &quot;单缓冲&quot;">​</a></h3><ul><li>单缓冲是串行的</li><li>每个块时间为 T + M + C = 10 + 6 + 2 = 18μs</li><li>10 * 18 = 180μs</li></ul><h2 id="移臂调度算法" tabindex="-1">移臂调度算法 <a class="header-anchor" href="#移臂调度算法" aria-label="Permalink to &quot;移臂调度算法&quot;">​</a></h2><p>先寻道，再考虑扇区（从小到大）</p><h3 id="先来先服务-fcfs" tabindex="-1">先来先服务（FCFS） <a class="header-anchor" href="#先来先服务-fcfs" aria-label="Permalink to &quot;先来先服务（FCFS）&quot;">​</a></h3><img src="'+d+'"><h3 id="最短寻道时间优先-sstf-【贪心算法】" tabindex="-1"><strong>最短寻道时间优先（SSTF）【贪心算法】</strong> <a class="header-anchor" href="#最短寻道时间优先-sstf-【贪心算法】" aria-label="Permalink to &quot;**最短寻道时间优先（SSTF）【贪心算法】**&quot;">​</a></h3><img src="'+s+'"><h3 id="扫描算法-scan-【双向】" tabindex="-1">扫描算法（scan）【双向】 <a class="header-anchor" href="#扫描算法-scan-【双向】" aria-label="Permalink to &quot;扫描算法（scan）【双向】&quot;">​</a></h3><h3 id="循环扫描算法-cscan-【单向】" tabindex="-1">循环扫描算法（CSCAN）【单向】 <a class="header-anchor" href="#循环扫描算法-cscan-【单向】" aria-label="Permalink to &quot;循环扫描算法（CSCAN）【单向】&quot;">​</a></h3>',38)]))}const R=a(o,[["render",n]]);export{_ as __pageData,R as default};

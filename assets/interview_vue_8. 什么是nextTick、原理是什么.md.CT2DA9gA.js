import{_ as t,c as a,ag as i,o as l}from"./chunks/framework.BxW8Wou5.js";const u=JSON.parse('{"title":"8. 什么是nextTick? 原理是什么?","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue/8. 什么是nextTick、原理是什么.md","filePath":"interview/vue/8. 什么是nextTick、原理是什么.md","lastUpdated":1705937785000}'),c={name:"interview/vue/8. 什么是nextTick、原理是什么.md"};function n(r,e,s,o,_,p){return l(),a("div",null,e[0]||(e[0]=[i('<h1 id="_8-什么是nexttick-原理是什么" tabindex="-1">8. 什么是nextTick? 原理是什么? <a class="header-anchor" href="#_8-什么是nexttick-原理是什么" aria-label="Permalink to &quot;8. 什么是nextTick? 原理是什么?&quot;">​</a></h1><p>在vue中，页面里的数据改变后，会触发setter，并通过Dep通知对应的Watcher执行_update,<a href="./2.说说Vue响应式原理.html">详见vue响应式原理</a>。这个过程是异步的。</p><p>如果没有nextTick更新机制，每次更新数据都会触发视图更新，有了nextTick以后只需要更新一次。</p><h2 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h2><p>next-tick.js中维护了一个<code>callbacks</code>队列、一个<code>pending</code>锁、一个<code>timerFunc</code>函数</p><ul><li><p>callbacks队列收集当前正在执行任务队列中所有nextTick回调，等当前任务队列执行完之后好一次性for循环啪执行完。</p></li><li><p>timerFunc函数是根据当前浏览器环境判断得出一个能够产生微任务或降级为计时器任务的api调用。（将flushCallbacks放入微队列）</p><ul><li>优先使用Promise</li><li>再者是MutationObserver</li><li>再或者是setImmediate</li><li>最后是setTimeout</li></ul></li><li><p>当pending锁为fasle时，表示第一次向callbacks队列添加回调函数，只需要在这时候执行timerfunc，创建一个为任务就好。</p></li><li><p>等当前任务队列执行完毕后，就会去执行微队列中的flushCallbacks（利用for循环执行callbacks），并将pending设置为false。</p></li></ul>',6)]))}const k=t(c,[["render",n]]);export{u as __pageData,k as default};

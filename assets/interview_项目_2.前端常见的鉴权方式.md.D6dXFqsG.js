import{_ as i,c as a,ag as o,o as t}from"./chunks/framework.BxW8Wou5.js";const u=JSON.parse('{"title":"2.前端常见的鉴权方式","description":"","frontmatter":{},"headers":[],"relativePath":"interview/项目/2.前端常见的鉴权方式.md","filePath":"interview/项目/2.前端常见的鉴权方式.md","lastUpdated":1705937785000}'),l={name:"interview/项目/2.前端常见的鉴权方式.md"};function r(c,e,n,s,d,h){return t(),a("div",null,e[0]||(e[0]=[o('<h1 id="_2-前端常见的鉴权方式" tabindex="-1">2.前端常见的鉴权方式 <a class="header-anchor" href="#_2-前端常见的鉴权方式" aria-label="Permalink to &quot;2.前端常见的鉴权方式&quot;">​</a></h1><h2 id="http-basic-authentication-http基本鉴权" tabindex="-1">HTTP Basic Authentication（HTTP基本鉴权） <a class="header-anchor" href="#http-basic-authentication-http基本鉴权" aria-label="Permalink to &quot;HTTP Basic Authentication（HTTP基本鉴权）&quot;">​</a></h2><p><strong>大部分项目已经不使用此方案，了解即可</strong></p><h3 id="流程" tabindex="-1">流程 <a class="header-anchor" href="#流程" aria-label="Permalink to &quot;流程&quot;">​</a></h3><p>流程如下：</p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d577adb5dd164d7880f711c2ec579827~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?"><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>兼容性好</li></ul><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>安全性差，以base64格式在http中传输，容易被截获解码，容易被重放攻击。</li><li>无法主动注销</li></ul><h2 id="session-cookie机制" tabindex="-1">Session-Cookie机制 <a class="header-anchor" href="#session-cookie机制" aria-label="Permalink to &quot;Session-Cookie机制&quot;">​</a></h2><p>利用服务端Session和客户端Cookie来实现前后端通信认证模式</p><h3 id="流程-1" tabindex="-1">流程 <a class="header-anchor" href="#流程-1" aria-label="Permalink to &quot;流程&quot;">​</a></h3><p>流程如下：</p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/62cb87d3cf2c4e958a7a2514913b005b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?"><ul><li>客户端（浏览器）：向服务器发送登录信息的用户名/密码来请求登录校验</li><li>服务端：验证信息 -&gt; 通过后创建Session（保存在内存/Redis中）-&gt; 给此session生成唯一id -&gt; 在响应头（set-cookie）中设置</li></ul><blockquote><p>可以对sessionid进行加密，验证时服务端解密。</p></blockquote><ul><li>客户端（浏览器）：收到服务器的响应后会解析响应头，并自动将<code>sessionid</code>保存在本地 Cookie 中，浏览器在下次 HTTP 请求时请求头会自动附带上该域名下的 Cookie 信息；</li><li>服务端：接收客户端请求时会去解析请求头 Cookie 中的 <code>sessionid</code>，然后根据这个 <code>sessionid</code> 去找服务端保存的该客户端的 <code>sessionid</code>，然后判断该请求是否合法</li></ul><h3 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>cookie简单易用</li><li>session存储在服务端，相比JWT好管理</li><li>只需要后端操作，前端无感</li></ul><h3 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>依赖Cookie，用户禁用Cookie就失效</li><li>安全性差，暴露在浏览器中</li><li>增加服务器开销</li><li>对移动端支持不好（ios和android cookie操作不方便）</li><li>对分布式应用支持不友好</li></ul><h2 id="token机制-jwt" tabindex="-1">Token机制(JWT) <a class="header-anchor" href="#token机制-jwt" aria-label="Permalink to &quot;Token机制(JWT)&quot;">​</a></h2><p><code>Token</code> 是一个令牌，客户端访问服务器时，验证通过后服务端会为其签发一张令牌，之后，客户端就可以携带令牌访问服务器，服务端只需要验证令牌的有效性即可。</p><p>JWT一般由Header（头部）、Payload（载荷）、Signature（签名）组成，中间用.隔开。Header是一个描述JWT元数据的Json对象（算法alg、类型typ）；payload是主体部分，保存实体信息（到期时间exp，发行人iss，主题sub，用户aud等...，也可以定义私有字段）；signature签名是对上面两个部分数据利用指定密钥进行签名</p><ul><li>payload和header只是简单的base64加密，因此payload不存储敏感信息</li><li>signature为不可逆加密，仅用作校验Token是否被篡改</li><li>避免存储过多信息</li></ul><h3 id="流程-2" tabindex="-1">流程 <a class="header-anchor" href="#流程-2" aria-label="Permalink to &quot;流程&quot;">​</a></h3><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7beef40b29b14043ba5b0cea04d2a72f~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?"><ul><li>客户端（浏览器）:输入用户名和密码请求登录校验</li><li>服务器：收到请求，去验证用户名和密码；验证成功后，服务端签发token并发给前端</li><li>客户端（浏览器）：收到Token后存储到localStorage或cookie中</li><li>客户端发送请求时：将Token通过请求头的Authorization字段（可自定义）发送至服务端</li><li>服务器：验证Token可用性，通过返回数据，否则报错。</li></ul><h3 id="refresh-token" tabindex="-1">Refresh Token <a class="header-anchor" href="#refresh-token" aria-label="Permalink to &quot;Refresh Token&quot;">​</a></h3><p><strong>为了避免Token因有效期过短过期，提出了Refresh Token这个概念</strong></p><ul><li>Access Token：用于验证业务</li><li>Refresh Token: 用于获取Access Token，有效期比Access Token长</li></ul><h4 id="流程-3" tabindex="-1">流程 <a class="header-anchor" href="#流程-3" aria-label="Permalink to &quot;流程&quot;">​</a></h4><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac396824cc4b4a88b5f57d84c1f856cc~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?"><ul><li>客户端（浏览器）:输入用户名和密码请求登录校验</li><li>服务器：收到请求，去验证用户名和密码；验证成功后，服务端签发<code>Access Token</code>和<code>Refresh Token</code>并发给前端</li><li>客户端（浏览器）：收到Token后存储到localStorage或cookie中</li><li>客户端发送请求时：将<code>Access Token</code>通过请求头的Authorization字段（可自定义）发送至服务端 <ul><li>验证<code>Access Token</code>有效：正常返回数据</li><li>验证<code>Access Token</code>过期：拒绝请求</li></ul></li><li>客户端（Access Token过期）：传输Refresh Token给后端</li><li>服务端（Access Token过期）：验证 Refresh Token ，验证成功后返回新的 Access Token 给客户端；</li><li>服务器：重新携带新的 Access Token 请求接口；</li></ul><h3 id="优点-2" tabindex="-1">优点 <a class="header-anchor" href="#优点-2" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>服务端无状态，利于微服务（分布式）应用</li><li>支持App端设备</li><li>有效避免CSRF</li><li>支持跨程序调用</li></ul><h3 id="缺点-2" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-2" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>到期前无法手动失效</li></ul><h2 id="sso-single-sign-on-单点登录" tabindex="-1">SSO（Single Sign On - 单点登录） <a class="header-anchor" href="#sso-single-sign-on-单点登录" aria-label="Permalink to &quot;SSO（Single Sign On - 单点登录）&quot;">​</a></h2><h3 id="同域sso-主域名相同" tabindex="-1">同域SSO(主域名相同) <a class="header-anchor" href="#同域sso-主域名相同" aria-label="Permalink to &quot;同域SSO(主域名相同)&quot;">​</a></h3><p>当百度网站存在两个相同主域名下的贴吧子系统 <code>tieba.baidu.com</code> 和网盘子系统 <code>pan.baidu.com</code> 时，以下为他们实现 SSO 的步骤：</p><ul><li>客户端：用户访问某个子系统时（<code>tieba.baidu.com</code>），如果没有登录，则跳转至SSO认证中心（<code>sso.baidu.com</code>）提供的登陆页面进行登录</li><li>服务端：登录认证后，服务端把登录信息存储于Session中，并且附加在响应头的set-cookie字段中（设置Cookie的domain为<code>.baidu.com</code>）</li></ul><h3 id="异域sso-主域名不同" tabindex="-1">异域SSO（主域名不同） <a class="header-anchor" href="#异域sso-主域名不同" aria-label="Permalink to &quot;异域SSO（主域名不同）&quot;">​</a></h3><p>传统：使用CAS（中央授权服务）</p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7a034d58b8db41c6a9a049bc4c0890b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?"><ul><li>用户通过浏览器访问某个应用系统（CAS Client），该系统发现用户没有登录，于是返回302状态码，并且携带上一个service参数，让用户去CAS Server上登录。</li><li>浏览器自动重定向到CAS Server上，CAS Server获取用户Cookie中携带的TGC（Ticket Granting Cookie），去校验用户是否已经登录，如果已经登录，则完成身份校验（此时CAS Server可以根据用户的TGC找到TGT（Ticket Granting Ticket），进而获取用户的信息）；<strong>如果未登录</strong>，则重定向到CAS Server的登录页面，用户输入用户名/密码，CAS Server会生成TGT，并且根据TGT签发一个ST（Service Ticket），再将TGC放在用户的Cookie中，完成身份校验。</li><li>CAS Server完成身份校验之后，会将ST拼接在service中，返回302状态码，浏览器将首先将TGC存在Cookie中，然后根据302的指示，携带上ST重定向到应用系统。</li><li>应用系统收到浏览器传来的ST之后，拿去CAS Server上校验，去判断用户的登录状态，如果用户登录合法，CAS Server就会返回用户信息给应用系统。应用系统可以根据用户信息建立一个局部的会话，把Cookie发给浏览器，同时返回请求页面的内容。</li><li>如果用户再去访问另一个应用系统（CAS Client），该系统也会重定向到CAS Server，CAS Server发现此时用户实际上已经登录了，于是又重定向回应用系统，同时携带上ST。应用系统拿着ST去CAS Server上校验，获取用户的登录信息。</li></ul><h4 id="tgt-ticket-granting-cookie" tabindex="-1">TGT(Ticket-granting cookie) <a class="header-anchor" href="#tgt-ticket-granting-cookie" aria-label="Permalink to &quot;TGT(Ticket-granting cookie)&quot;">​</a></h4><p>存放用户身份认证凭证的cookie，在浏览器和CAS Server间通讯时使用。</p><h4 id="tgc-ticket-granting-ticket" tabindex="-1">TGC(Ticket-granting ticket) <a class="header-anchor" href="#tgc-ticket-granting-ticket" aria-label="Permalink to &quot;TGC(Ticket-granting ticket)&quot;">​</a></h4><p>TGT对象的ID就是TGC的值，在服务器端，通过TGC查询TGT。TGT封装了TGC值以及此Cookie值对应的用户信息。</p><h2 id="oauth2-0" tabindex="-1">OAUTH2.0 <a class="header-anchor" href="#oauth2-0" aria-label="Permalink to &quot;OAUTH2.0&quot;">​</a></h2><h3 id="授权码模式" tabindex="-1">授权码模式 <a class="header-anchor" href="#授权码模式" aria-label="Permalink to &quot;授权码模式&quot;">​</a></h3><img src="https://p4.itc.cn/q_70/images03/20230707/38d5582a3ec84ea2bbcf63d2bfc5abdf.jpeg">',54)]))}const b=i(l,[["render",r]]);export{u as __pageData,b as default};

import{_ as i,c as a,ag as e,o as l}from"./chunks/framework.BxW8Wou5.js";const c=JSON.parse('{"title":"3. 阐述Vue的diff（patch）算法","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue/3. Vue的diff算法.md","filePath":"interview/vue/3. Vue的diff算法.md","lastUpdated":1705937785000}'),n={name:"interview/vue/3. Vue的diff算法.md"};function t(h,s,p,d,k,r){return l(),a("div",null,s[0]||(s[0]=[e(`<h1 id="_3-阐述vue的diff-patch-算法" tabindex="-1">3. 阐述Vue的diff（patch）算法 <a class="header-anchor" href="#_3-阐述vue的diff-patch-算法" aria-label="Permalink to &quot;3. 阐述Vue的diff（patch）算法&quot;">​</a></h1><p>当组件创建和更新时，vue均会执行内部的update函数，该函数在内部调用render函数生成虚拟dom树，组件会指向新树，然后vue将新旧两树进行对比，找到差异点，最终更新到真实dom对比差异的过程叫diff，vue在内部通过一个叫patch的函数完成该过程在对比时，vue采用深度优先、逐层比较的方式进行比对。</p><p>在判断两个节点是否相同时，vue是通过虚拟节点的key和tag来进行判断的</p><p>具体来说，首先对根节点进行对比，如果相同则将旧节点关联的真实dom的引用挂到新节点上，然后根据需要更新属性到真实dom，然后再对比其子节点数组;如果不相同，则按照新节点的信息递归创建所有真实dom，同时挂到对应虚拟节点上，然后移除掉旧的dom。</p><p>在对比其子节点数组时，vue对每个子节点数组使用了两个指针，分别指向头尾，然后不断向中间靠拢来进行对比，这样做的目的是尽量复用真实dom，尽量少的销毁和创建真实dom。如果发现相同，则进入和根节点一样的对比流程，如果发现不同，则移动真实dom到合适的位置</p><p>这样一直递归的遍历下去，直到整棵树完成对比。</p><h2 id="diff的时机" tabindex="-1">diff的时机 <a class="header-anchor" href="#diff的时机" aria-label="Permalink to &quot;diff的时机&quot;">​</a></h2><p>当组件创建时，以及依赖的属性或数据变化时，会运行一个函数，该函数会做两件事：</p><ul><li>运行_render生成一颗新的虚拟dom树（vnode tree）</li><li>运行_update，传入虚拟dom树的根节点，对新旧两棵树进行对比，最终完成对真实dom的更新</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Vue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...其他代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> updateComponent</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_render</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> watcher</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(updateComponent)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...其他代码</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p><strong>diff就发生在_update函数的运行过程中</strong></p><h2 id="update函数在干什么" tabindex="-1">_update函数在干什么 <a class="header-anchor" href="#update函数在干什么" aria-label="Permalink to &quot;_update函数在干什么&quot;">​</a></h2><p><code>_update</code>函数接收到一个<code>vnode</code>参数，这就是新生成的虚拟dom树 同时，<code>_update</code>函数会通过当前组件的<code>_vode</code>属性拿到旧的虚拟dom树 <code>_update</code>函数首先会给组件的<code>_vode</code>属性重新赋值，让它指向新树</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 以下为伪代码</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> _update</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // vode: 新树</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // this._vode: 旧</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oldVnode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._vode</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">._vode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vnode</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 对比的目的： 更新真实DOM</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">oldVnode) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // el为根节点</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">_patch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.$el, vnode)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span></code></pre></div><p>然后会判断旧树是否存在：</p><ul><li>不存在：<strong>说明是第一次加载组件</strong>，于是通过内部的<code>patch</code>函数，直接遍历新树，为每个节点生成真实DOM，然后挂载到每个节点的elm属性上（在树中记录真实DOM）</li><li>存在：<strong>说明之前已经渲染过组件</strong>，于是通过内部的<code>patch</code>函数，对新旧两棵树进行对比，以达到下面两个目标 <ul><li>完成对真实DOM的最小化处理</li><li>让新树的节点对应合适的真实DOM</li></ul></li></ul><h2 id="patch函数" tabindex="-1">patch函数 <a class="header-anchor" href="#patch函数" aria-label="Permalink to &quot;patch函数&quot;">​</a></h2><h3 id="术语解释" tabindex="-1">术语解释 <a class="header-anchor" href="#术语解释" aria-label="Permalink to &quot;术语解释&quot;">​</a></h3><ul><li>相同：两个虚拟节点的标签类型、key值均相同，但input元素还要对比type属性</li><li>新建元素：是指根据一个虚拟节点提供的信息，创建一个真实DOM元素，同时挂载到虚拟节点的elm属性上</li><li>销毁元素：是指<code>vnode.elm.remove()</code></li><li>更新：是指对两个虚拟节点对比更新，它仅发生在两个虚拟节点<strong>相同</strong>的情况下。</li><li>对比子节点： 是指对两个虚拟节点的子节点进行对比。</li></ul><h2 id="详细流程" tabindex="-1">详细流程 <a class="header-anchor" href="#详细流程" aria-label="Permalink to &quot;详细流程&quot;">​</a></h2><h3 id="_1-对比根节点" tabindex="-1">1. 对比根节点 <a class="header-anchor" href="#_1-对比根节点" aria-label="Permalink to &quot;1. 对比根节点&quot;">​</a></h3><p>patch函数首先对根节点进行比较</p><p>如果两个节点：</p><ul><li>相同，进入<strong>更新</strong>流程 <ul><li><ol><li>将旧节点的真实DOM赋值到新节点：newVnode.elm = oldVnode.elm</li></ol></li><li><ol start="2"><li>对比新节点和旧节点的属性，有变化的更新到真实DOM中</li></ol></li><li><ol start="3"><li>当前两个节点处理完毕，开始<strong>对比子节点</strong></li></ol></li></ul></li><li>不相同，进入<strong>创建</strong>流程 <ul><li>新节点<strong>递归</strong>创建元素</li><li>旧节点销毁元素</li></ul></li></ul><h3 id="_2-对比子节点" tabindex="-1">2. 对比子节点 <a class="header-anchor" href="#_2-对比子节点" aria-label="Permalink to &quot;2. 对比子节点&quot;">​</a></h3><p>在对比子节点中，vue的原则是：</p><ul><li>尽量不要有操作</li><li>不行的话，尽量改动元素属性</li><li>还不行的话，尽量移动元素，而不是删除和创建元素</li><li>还不行的话，删除和创建元素</li></ul><h2 id="对开发的影响" tabindex="-1">对开发的影响 <a class="header-anchor" href="#对开发的影响" aria-label="Permalink to &quot;对开发的影响&quot;">​</a></h2><h3 id="v-for循环时候加上key值" tabindex="-1">v-for循环时候加上key值 <a class="header-anchor" href="#v-for循环时候加上key值" aria-label="Permalink to &quot;v-for循环时候加上key值&quot;">​</a></h3><p>如果不加上<code>key</code>值，当v-for循环的数组发生变化需要重新渲染时，vue就会认为前后节点相同，而去频繁的对比子节点，修改内容，容易造成页面卡顿。 如果加上<code>key</code>值，vue就会进入创建流程</p>`,30)]))}const E=i(n,[["render",t]]);export{c as __pageData,E as default};

import{_ as a,c as i,ag as e,o as t}from"./chunks/framework.BxW8Wou5.js";const r="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-%E6%95%B0%E6%8D%AE%E6%B5%81%E9%A3%8E%E6%A0%BC.png",E="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-%E8%B0%83%E7%94%A8%E8%BF%94%E5%9B%9E%E9%A3%8E%E6%A0%BC.png",o="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-%E7%8B%AC%E7%AB%8B%E6%9E%84%E4%BB%B6%E9%A3%8E%E6%A0%BC.png",n="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-%E7%8B%AC%E7%AB%8B%E6%9E%84%E4%BB%B6%E9%A3%8E%E6%A0%BC%E7%BB%84%E6%88%90.png",h="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%A3%8E%E6%A0%BC.png",u="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%A3%8E%E6%A0%BC-%E8%A7%A3%E9%87%8A%E5%99%A8%E5%BC%95%E6%93%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC.png",c="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%A3%8E%E6%A0%BC-%E8%A7%84%E5%88%99%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E9%A3%8E%E6%A0%BC.png",p="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-%E9%BB%91%E6%9D%BF%E9%A3%8E%E6%A0%BC.png",s="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-%E9%97%AD%E7%8E%AF%E6%8E%A7%E5%88%B6%E9%A3%8E%E6%A0%BC.png",d="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC-C2%E6%9E%B6%E6%9E%84%E9%A3%8E%E6%A0%BC.png",B="/blog/picture/%E8%BD%AF%E8%80%83/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AF%84%E4%BC%B0.png",P=JSON.parse('{"title":"4.软件架构风格（重要）","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/系统架构师/第5章 - 软件架构设计/4.软件架构风格.md","filePath":"ruankao/系统架构师/第5章 - 软件架构设计/4.软件架构风格.md","lastUpdated":null}'),A={name:"ruankao/系统架构师/第5章 - 软件架构设计/4.软件架构风格.md"};function m(b,l,_,q,g,C){return t(),i("div",null,l[0]||(l[0]=[e('<h1 id="_4-软件架构风格-重要" tabindex="-1">4.软件架构风格（重要） <a class="header-anchor" href="#_4-软件架构风格-重要" aria-label="Permalink to &quot;4.软件架构风格（重要）&quot;">​</a></h1><p>每年综合知识（选择）都会考几分</p><h2 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h2><p><strong>架构风格定义了用于描述系统的术语表和一组指导构建系统的规则</strong></p><p>架构定义过程中需要把共性定义出来。比如建筑风格（中式、日式、美式）</p><h2 id="五大架构风格" tabindex="-1">五大架构风格 <a class="header-anchor" href="#五大架构风格" aria-label="Permalink to &quot;五大架构风格&quot;">​</a></h2><h3 id="数据流风格【data-flow】" tabindex="-1">数据流风格【Data Flow】 <a class="header-anchor" href="#数据流风格【data-flow】" aria-label="Permalink to &quot;数据流风格【Data Flow】&quot;">​</a></h3><img src="'+r+'"><p>把数据的处理分步骤进行</p><p>前一步的处理结果是后一步的输入内容【数据驱动】</p><ul><li>优点 <ul><li>松耦合【高内聚-低耦合】</li><li>良好的重用性/可维护性</li><li>可拓展性</li><li>良好的隐蔽性</li><li>支持并行</li></ul></li><li>缺点 <ul><li>交互性较差</li><li>复杂性较高</li><li>性能较差（每个过滤器都需要解析和合成数据）</li></ul></li><li>典型实例 <ul><li>传统编译器（C 语言）</li><li>网络报文处理</li></ul></li></ul><h4 id="批处理" tabindex="-1">批处理 <a class="header-anchor" href="#批处理" aria-label="Permalink to &quot;批处理&quot;">​</a></h4><p>大量整体数据（成批导入），无需用户交互</p><h4 id="管道-过滤器" tabindex="-1">管道-过滤器 <a class="header-anchor" href="#管道-过滤器" aria-label="Permalink to &quot;管道-过滤器&quot;">​</a></h4><p>流式数据、弱用户交互</p><h3 id="调用-返回风格【call-return】" tabindex="-1">调用/返回风格【Call/Return】 <a class="header-anchor" href="#调用-返回风格【call-return】" aria-label="Permalink to &quot;调用/返回风格【Call/Return】&quot;">​</a></h3><img src="'+E+'"><p>系统开发过程中用得最多的风格，</p><p>流程：主函数调用子函数，子函数计算结果后返回</p><h4 id="主程序-子程序" tabindex="-1">主程序/子程序 <a class="header-anchor" href="#主程序-子程序" aria-label="Permalink to &quot;主程序/子程序&quot;">​</a></h4><p>面向过程</p><h4 id="面向对象" tabindex="-1">面向对象 <a class="header-anchor" href="#面向对象" aria-label="Permalink to &quot;面向对象&quot;">​</a></h4><p>对象的方法调用</p><h4 id="分层架构-相对重要" tabindex="-1">分层架构（相对重要） <a class="header-anchor" href="#分层架构-相对重要" aria-label="Permalink to &quot;分层架构（相对重要）&quot;">​</a></h4><p>层与层之间的方法调用</p><p>例如 ISO 七层模型</p><ul><li>优点 <ul><li>良好的重用性，只要接口不变可用在其他处</li><li>可维护性好</li><li>可扩展性好，支持递增设计</li></ul></li><li>缺点 <ul><li>并不是每个系统都方便分层</li><li>很难找到一个合适的、正确的层次抽象方法</li><li>不同层次之间耦合度高的系统很难实现</li></ul></li><li>特点 <ul><li>各个层次的组件形成不同功能级别的虚拟机</li><li>多层相互协同工作，而且实现透明</li></ul></li></ul><h3 id="独立构件风格【independent-components】" tabindex="-1">独立构件风格【Independent Components】 <a class="header-anchor" href="#独立构件风格【independent-components】" aria-label="Permalink to &quot;独立构件风格【Independent Components】&quot;">​</a></h3><img src="'+o+'"><p>类似于 onClick 事件</p><ul><li>优点 <ul><li>松耦合</li><li>良好的重用性/可修改性/可拓展性</li></ul></li><li>缺点 <ul><li>构件放弃了对系统计算的控制。一个构件触发一个事件时，不能确定其他构件是否会响应它。而且即使它知道事件注册了哪些构件的过程，它也不能保证这些过程被调用的顺序</li><li>数据交换的问题</li><li>既然过程的语义必须依赖于被触发事件的上下文约束，关于正确性的推理就存在问题</li></ul></li><li>特点 <ul><li>系统由若干子系统构成且成为一个整体</li><li>系统有统一的目标</li><li>系统有主从之分</li><li>每一个子系统有自己的事件收集和处理机制</li></ul></li></ul><img src="'+n+'"><h4 id="进程通信体系结构风格" tabindex="-1">进程通信体系结构风格 <a class="header-anchor" href="#进程通信体系结构风格" aria-label="Permalink to &quot;进程通信体系结构风格&quot;">​</a></h4><h4 id="基于事件的隐式调用风格" tabindex="-1">基于事件的隐式调用风格 <a class="header-anchor" href="#基于事件的隐式调用风格" aria-label="Permalink to &quot;基于事件的隐式调用风格&quot;">​</a></h4><p>组件（或模块）不直接调用其他组件提供的特定服务，而是通过发布（发出）事件来广播自身状态的改变或发生的特定情况。其他对这些事件感兴趣的组件则订阅（监听）这些事件，并在事件发生时自动执行相应的处理逻辑。</p><p>可以将其想象成广播电台和听众。电台（事件发布者）播放节目（发布事件），它不知道有哪些听众（事件订阅者）在收听，也不知道听众会如何反应。听众（事件订阅者）根据自己的兴趣选择收听特定的节目（订阅特定的事件），并在节目播放时做出相应的反应（执行事件处理逻辑）。</p><h3 id="虚拟机风格【virtual-machine】" tabindex="-1">虚拟机风格【Virtual Machine】 <a class="header-anchor" href="#虚拟机风格【virtual-machine】" aria-label="Permalink to &quot;虚拟机风格【Virtual Machine】&quot;">​</a></h3><img src="'+h+'"><p>Java 因为引入了虚拟机使得 Java 程序可以跨平台运行</p><h4 id="解释器" tabindex="-1">解释器 <a class="header-anchor" href="#解释器" aria-label="Permalink to &quot;解释器&quot;">​</a></h4><img src="'+u+'"><p>解释器引擎解释的是自定义的要被解释的代码</p><ul><li>适合领域 <ul><li>适用于需要“自定义规则”的场合</li></ul></li></ul><h4 id="以规则为中心" tabindex="-1">以规则为中心 <a class="header-anchor" href="#以规则为中心" aria-label="Permalink to &quot;以规则为中心&quot;">​</a></h4><p>加强版解释器</p><img src="'+c+'"><ul><li><p>特点</p><ul><li>在解释器的基础上增加经验规则</li></ul></li><li><p>适合领域</p><ul><li>适用于专家系统</li></ul></li></ul><p>两种子风格都可以灵活应对自定义场景，缺点都是复杂度较高</p><h3 id="以数据为中心-仓库风格-【data-centered】" tabindex="-1">以数据为中心（仓库风格）【Data-centered】 <a class="header-anchor" href="#以数据为中心-仓库风格-【data-centered】" aria-label="Permalink to &quot;以数据为中心（仓库风格）【Data-centered】&quot;">​</a></h3><h4 id="数据库系统" tabindex="-1">数据库系统 <a class="header-anchor" href="#数据库系统" aria-label="Permalink to &quot;数据库系统&quot;">​</a></h4><ul><li>特点 <ul><li>以数据为中心</li></ul></li></ul><h4 id="黑板系统-语音识别、知识推理" tabindex="-1">黑板系统：语音识别、知识推理 <a class="header-anchor" href="#黑板系统-语音识别、知识推理" aria-label="Permalink to &quot;黑板系统：语音识别、知识推理&quot;">​</a></h4><img src="'+p+'"><p>可以用数据库系统实现 只是增加了触发机制。</p><ul><li>优点 <ul><li>可更改性和可维护性</li><li>可重用性的知识源</li><li>容错性和健壮性</li></ul></li><li>缺点 <ul><li>测试困难</li><li>不能保证有好的解决方案</li><li>难以建立好的控制策略</li><li>低效</li><li>开发困难</li><li>缺少并行机制</li></ul></li><li>特点 <ul><li>在以数据为中心的基础上，使用中心数据触发业务逻辑部件</li></ul></li><li>典型实例 <ul><li>语音识别</li><li>模式识别</li><li>图像处理</li><li>知识推理</li></ul></li></ul><h4 id="超文本系统" tabindex="-1">超文本系统 <a class="header-anchor" href="#超文本系统" aria-label="Permalink to &quot;超文本系统&quot;">​</a></h4><h3 id="闭环控制风格-过程控制" tabindex="-1">闭环控制风格（过程控制） <a class="header-anchor" href="#闭环控制风格-过程控制" aria-label="Permalink to &quot;闭环控制风格（过程控制）&quot;">​</a></h3><p>一般在嵌入式系统里应用的比较多，不适合复杂场景</p><img src="'+s+'"><p><strong>开环控制</strong>：看电视 -&gt; 遥控器发出指令 -&gt; 电视接收指令（数据发出以后，数据没有回来）</p><p><strong>闭环控制</strong>：夏天炎热 -&gt; 开空调 -&gt; 调 18 度 -&gt; 空调控制压缩机全力制冷 -&gt; 通过 10 分钟极速降温 -&gt; 对比是否到达 18 度 -&gt; 到达则停止（会跟进数据是否有到达预期）</p><h3 id="c2-架构风格" tabindex="-1">C2 架构风格 <a class="header-anchor" href="#c2-架构风格" aria-label="Permalink to &quot;C2 架构风格&quot;">​</a></h3><p>是层次架构风格的一种</p><img src="'+d+'"><h2 id="软件架构评估" tabindex="-1">软件架构评估 <a class="header-anchor" href="#软件架构评估" aria-label="Permalink to &quot;软件架构评估&quot;">​</a></h2><img src="'+B+'"><p>-：表示负相关，例如性能提升安全性则下降</p><p>+：表示正相关，例如可维护性提升则可用性提升</p><h2 id="mda-理想化状态下的产物" tabindex="-1">MDA（理想化状态下的产物） <a class="header-anchor" href="#mda-理想化状态下的产物" aria-label="Permalink to &quot;MDA（理想化状态下的产物）&quot;">​</a></h2><p>Model Driven Architecture（模型驱动架构）</p><p>使用模型完成软件的分析、设计、构件、部署、维护等各开发活动</p><h3 id="主要目标" tabindex="-1">主要目标 <a class="header-anchor" href="#主要目标" aria-label="Permalink to &quot;主要目标&quot;">​</a></h3><ul><li>可移植性</li><li>互通性</li><li>可重用性</li></ul><h3 id="核心模型" tabindex="-1">核心模型 <a class="header-anchor" href="#核心模型" aria-label="Permalink to &quot;核心模型&quot;">​</a></h3><ul><li>计算无关 CIM：对某具体行业内一个项目的业务需求及其系统功能需求进行分析</li><li>平台独立 PIM：具有高抽象层次、独立于任何实现技术的模型</li><li>平台相关 PSM：为某种特定实现技术量身定做，让你用这种技术中可用的实现构造来描述系统的模型。PIM 会被变换成一个或多个 PSM</li><li>代码 Code：用源代码对系统的描述。每个 PSM 都将被变换成代码。</li></ul>',75)]))}const k=a(A,[["render",m]]);export{P as __pageData,k as default};

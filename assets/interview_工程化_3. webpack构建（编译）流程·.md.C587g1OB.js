import{_ as e,c as t,ag as s,o as i}from"./chunks/framework.BxW8Wou5.js";const p=JSON.parse('{"title":"3. webpack构建（编译）流程","description":"","frontmatter":{},"headers":[],"relativePath":"interview/工程化/3. webpack构建（编译）流程·.md","filePath":"interview/工程化/3. webpack构建（编译）流程·.md","lastUpdated":1705937785000}'),n={name:"interview/工程化/3. webpack构建（编译）流程·.md"};function l(r,a,o,c,h,u){return i(),t("div",null,a[0]||(a[0]=[s('<h1 id="_3-webpack构建-编译-流程" tabindex="-1">3. webpack构建（编译）流程 <a class="header-anchor" href="#_3-webpack构建-编译-流程" aria-label="Permalink to &quot;3. webpack构建（编译）流程&quot;">​</a></h1><p>引用webpack官网的一张图</p><img src="https://pic1.zhimg.com/70/v2-f95dfe0b126b8de85c8e98beacdd335c_1440w.avis?source=172ae18b&amp;biz_tag=Post"><p><strong>webpack的作用就是将各种类型的资源，转换为JS格式的bundle文件，并交给浏览器处理。</strong></p><p>实现这个需求的过程需要经历三个阶段</p><ul><li>初始化</li><li>编译（构建、打包）</li><li>输出</li></ul><h2 id="初始化" tabindex="-1">初始化 <a class="header-anchor" href="#初始化" aria-label="Permalink to &quot;初始化&quot;">​</a></h2><p>该阶段将读取所有配置信息（命令行、配置文件）并合并成一个最终的配置文件。</p><p>接着会实例化Complier对象。Complier负责文件监听和启动编译。</p><p>该过程中会使用到第三方库<code>yargs</code></p><h2 id="编译-构建、打包" tabindex="-1">编译（构建、打包） <a class="header-anchor" href="#编译-构建、打包" aria-label="Permalink to &quot;编译（构建、打包）&quot;">​</a></h2><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h3><ul><li>dependence：依赖对象</li><li>chunk：webpack内部构建模块的块，一个chunk中包含多个模块，这些模块都是从入口模块通过依赖分析得来的。</li><li>module：模块，可以将js代码分解成单独的文件，便于维护。（不限于js，图片也可以是module）</li></ul><h3 id="创建chunk" tabindex="-1">创建chunk <a class="header-anchor" href="#创建chunk" aria-label="Permalink to &quot;创建chunk&quot;">​</a></h3><p>通过入口文件，分析整个依赖关系，创建一个chunk，每个chunk都有自己的名字</p><p>每个chunk至少有两个属性</p><ul><li>name：默认为main</li><li>id：唯一编号，开发环境同name，生产环境是一个数字，从0递增</li></ul><h3 id="构建所有依赖模块" tabindex="-1">构建所有依赖模块 <a class="header-anchor" href="#构建所有依赖模块" aria-label="Permalink to &quot;构建所有依赖模块&quot;">​</a></h3><ul><li>入口 <strong>--检查记录--&gt;</strong></li><li>已记录则结束，未记录则继续 <strong>-&gt;</strong></li><li>读取文件内容（调用loader） <strong>--语法分析--&gt;</strong></li><li>AST抽象语法树 <strong>--记录依赖--&gt;</strong></li><li>保存到dependencies中 <strong>-&gt;</strong></li><li>替换依赖函数 <strong>-&gt;</strong></li><li>保存转换后的模块代码</li></ul><p><strong>chunk中会产生一个模块列表，列表中包含了模块id（即路径 &#39;./src/a.js&#39; ）和模块转换后的代码</strong></p><h3 id="生成资源列表-chunk-assets" tabindex="-1">生成资源列表（chunk assets） <a class="header-anchor" href="#生成资源列表-chunk-assets" aria-label="Permalink to &quot;生成资源列表（chunk assets）&quot;">​</a></h3><p>接下来 webpack 会根据配置为chunk生成一个资源列表，即chunk assets，资源列表可以理解为是生成到最终文件的文件名和文件内容。</p><blockquote><p>chunk hash是根据所有chunk assets的内容生成的一个hash字符串 hash：一种算法，有多种分类，特点是将一个任意长度的字符串转换为一个固定长度的字符串，而且可以保证原始内容不变，产生的hash字符串就不变。</p></blockquote><h3 id="合并chunk-assets" tabindex="-1">合并chunk assets <a class="header-anchor" href="#合并chunk-assets" aria-label="Permalink to &quot;合并chunk assets&quot;">​</a></h3><p>将多个chunk的assets合并到一起，并产生一个总的hash</p><h2 id="输出" tabindex="-1">输出 <a class="header-anchor" href="#输出" aria-label="Permalink to &quot;输出&quot;">​</a></h2><p>webpack利用node的<code>fs</code>模块，根据编译产生的总的assets，生成相应的文件</p>',27)]))}const k=e(n,[["render",l]]);export{p as __pageData,k as default};

import{_ as e,c as l,ag as r,o as t}from"./chunks/framework.BxW8Wou5.js";const _=JSON.parse('{"title":"6、面向对象的设计原则（背）","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/软件设计师/第6章 - 面向对象/6.设计原则.md","filePath":"ruankao/软件设计师/第6章 - 面向对象/6.设计原则.md","lastUpdated":1761796671000}'),i={name:"ruankao/软件设计师/第6章 - 面向对象/6.设计原则.md"};function o(n,a,h,u,d,s){return t(),l("div",null,a[0]||(a[0]=[r('<h1 id="_6、面向对象的设计原则-背" tabindex="-1">6、面向对象的设计原则（背） <a class="header-anchor" href="#_6、面向对象的设计原则-背" aria-label="Permalink to &quot;6、面向对象的设计原则（背）&quot;">​</a></h1><h2 id="单一责任原则" tabindex="-1">单一责任原则 <a class="header-anchor" href="#单一责任原则" aria-label="Permalink to &quot;单一责任原则&quot;">​</a></h2><ul><li>就一个类而言，应该仅有一个引起它变化的原因</li></ul><h2 id="开放-封闭原则" tabindex="-1">开放-封闭原则 <a class="header-anchor" href="#开放-封闭原则" aria-label="Permalink to &quot;开放-封闭原则&quot;">​</a></h2><ul><li>软件实体（类、模块、函数）应该是可以拓展的（开放的），但是不可修改的（封闭的）</li></ul><h2 id="里氏替换原则" tabindex="-1">里氏替换原则 <a class="header-anchor" href="#里氏替换原则" aria-label="Permalink to &quot;里氏替换原则&quot;">​</a></h2><ul><li>子类必须能够替换父类</li><li>任何父类出现的地方，子类一定可以出现</li></ul><h2 id="依赖倒置原则" tabindex="-1">依赖倒置原则 <a class="header-anchor" href="#依赖倒置原则" aria-label="Permalink to &quot;依赖倒置原则&quot;">​</a></h2><ul><li>抽象不依赖于细节（实现），细节应该<strong>依赖于抽象</strong></li></ul><h2 id="接口分离原则" tabindex="-1">接口分离原则 <a class="header-anchor" href="#接口分离原则" aria-label="Permalink to &quot;接口分离原则&quot;">​</a></h2><ul><li>不应该强迫客户依赖于它们不用的方法</li><li>依赖于抽象，但不依赖于具体</li></ul><h2 id="共同封闭原则" tabindex="-1">共同封闭原则 <a class="header-anchor" href="#共同封闭原则" aria-label="Permalink to &quot;共同封闭原则&quot;">​</a></h2><ul><li>一个变化若对一个包产生影响，则这个变化对包中的所有类产生影响</li></ul><h2 id="共同重用原则" tabindex="-1">共同重用原则 <a class="header-anchor" href="#共同重用原则" aria-label="Permalink to &quot;共同重用原则&quot;">​</a></h2><ul><li>一个被重用，包中所有类都要被重用</li></ul>',15)]))}const m=e(i,[["render",o]]);export{_ as __pageData,m as default};

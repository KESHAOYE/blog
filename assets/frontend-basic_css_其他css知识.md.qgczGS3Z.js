import{_ as i,c as l,ag as s,o as t}from"./chunks/framework.BxW8Wou5.js";const e="/blog/picture/%E6%96%87%E5%AD%97%E5%8F%82%E8%80%83%E7%BA%BF.jpg",b=JSON.parse('{"title":"其他CSS知识","description":"","frontmatter":{},"headers":[],"relativePath":"frontend-basic/css/其他css知识.md","filePath":"frontend-basic/css/其他css知识.md","lastUpdated":1705937785000}'),n={name:"frontend-basic/css/其他css知识.md"};function o(r,a,h,p,d,c){return t(),l("div",null,a[0]||(a[0]=[s(`<h1 id="其他css知识" tabindex="-1">其他CSS知识 <a class="header-anchor" href="#其他css知识" aria-label="Permalink to &quot;其他CSS知识&quot;">​</a></h1><h2 id="规则" tabindex="-1">@规则 <a class="header-anchor" href="#规则" aria-label="Permalink to &quot;@规则&quot;">​</a></h2><p>at-rule：@规则、@语句、css语句</p><ol><li>import</li></ol><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**导入另一个CSS样式，优先解析 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;路径&#39;</span></span></code></pre></div><ol start="2"><li>charset</li></ol><p><strong>必须写在css第一行，可以省略</strong></p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/**告诉浏览器该CSS文件，使用的字符编码集是utf-8 */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@charset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> &#39;utf-8&#39;</span></span></code></pre></div><h2 id="web字体和图标" tabindex="-1">web字体和图标 <a class="header-anchor" href="#web字体和图标" aria-label="Permalink to &quot;web字体和图标&quot;">​</a></h2><h3 id="web字体" tabindex="-1">web字体 <a class="header-anchor" href="#web字体" aria-label="Permalink to &quot;web字体&quot;">​</a></h3><p>解决用户电脑没有安装相应字体的问题</p><p>当用户电脑上没有安装字体的时候，强制让用户下载该字体</p><ul><li>准备字体文件（*.ttf等）</li><li>使用font-face设置新字体（按照如下代码设置）:</li></ul><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@font-face</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  font-family</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;名称&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;路径&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="字体图标" tabindex="-1">字体图标 <a class="header-anchor" href="#字体图标" aria-label="Permalink to &quot;字体图标&quot;">​</a></h3><p>iconfont.cn</p><h2 id="块级格式化上下文-bfc-block-formatting-context" tabindex="-1">块级格式化上下文（BFC - Block Formatting Context） <a class="header-anchor" href="#块级格式化上下文-bfc-block-formatting-context" aria-label="Permalink to &quot;块级格式化上下文（BFC - Block Formatting Context）&quot;">​</a></h2><p>它是一块独立的渲染区域，它规定了在该区域中，常规流块盒的布局</p><ul><li>常规流块盒在水平方向上，必须撑满包含块（内容content + 填充padding + 边框border + 外边距margin = 包含块 content）</li><li>常规流快和在包含块的垂直方向上依次摆放</li><li>常规流块盒若外边距无缝相邻，则进行外边距合并</li><li>常规流块盒的自动高度和摆放位置，无视（浮动/定位-绝对定位、固定定位）元素</li></ul><p>BFC渲染区域：</p><p>这个区域由某个HTML元素创建，以下元素会在其内部创建BFC区域：</p><ul><li>根元素：意味着<code>&lt;html&gt;</code>元素创建的BFC区域，覆盖了网页中所有的元素</li><li>浮动和绝对定位元素</li><li>overflow不等于visible的元素（等于scroll、hidden等）<strong>副作用最小的一种方式</strong></li></ul><p><strong>不同的BFC区域在渲染时不互相干扰</strong></p><p><strong>具体规则如下:</strong></p><ul><li>创建BFC元素，他的自动高度需要计算浮动元素</li><li>创建BFC元素，他的边框盒不会和浮动元素重叠</li><li>创建BFC元素，不会和他的子元素进行外边框合并</li></ul><h2 id="body的背景" tabindex="-1">body的背景 <a class="header-anchor" href="#body的背景" aria-label="Permalink to &quot;body的背景&quot;">​</a></h2><h3 id="画布" tabindex="-1">画布 <a class="header-anchor" href="#画布" aria-label="Permalink to &quot;画布&quot;">​</a></h3><p>是一块区域</p><ol><li>最小宽度为视口（浏览器可视区域）宽度</li><li>最小高度为视口高度</li></ol><p><strong><code>&lt;HTML&gt;</code>元素的背景</strong></p><p>覆盖画布</p><p><strong><code>&lt;BODY&gt;</code>元素的背景</strong></p><p>如果<code>&lt;HTML&gt;</code>元素有背景，BODY元素正常（背景覆盖body的边框盒）</p><p>如果<code>&lt;HTML&gt;</code>元素没有背景，BODY元素的背景覆盖画布</p><p><strong>关于body或html的背景图片</strong></p><ol><li>背景图的宽度百分比，相对于视口</li><li>背景图高度的百分比，相对于HTML元素（整个网页的高度）</li><li>背景图横向位置的百分比、预设值（center等），都是相对于视口</li><li>背景图纵向位置的百分比、预设值（center等），都是相对于HTML元素（整个网页的高度）</li></ol><h2 id="行盒的垂直对齐" tabindex="-1">行盒的垂直对齐 <a class="header-anchor" href="#行盒的垂直对齐" aria-label="Permalink to &quot;行盒的垂直对齐&quot;">​</a></h2><h3 id="多个行盒垂直方向上的对齐" tabindex="-1">多个行盒垂直方向上的对齐 <a class="header-anchor" href="#多个行盒垂直方向上的对齐" aria-label="Permalink to &quot;多个行盒垂直方向上的对齐&quot;">​</a></h3><p>给没有对齐的元素设置vertical-align</p><ul><li>预设值（middle、bottom、super、）</li><li>百分比</li></ul><h3 id="图片的底部白边" tabindex="-1">图片的底部白边 <a class="header-anchor" href="#图片的底部白边" aria-label="Permalink to &quot;图片的底部白边&quot;">​</a></h3><p>图片的父元素是一个块盒子，块盒高度自动，底部会出现白边</p><ol><li>设置父元素的字体大小为0</li><li>将图片设置为块盒</li></ol><h2 id="参考线-深入理解字体-未完成" tabindex="-1">参考线-深入理解字体（未完成） <a class="header-anchor" href="#参考线-深入理解字体-未完成" aria-label="Permalink to &quot;参考线-深入理解字体（未完成）&quot;">​</a></h2><p>font-size、line-height、vertical-align、font-family</p><h3 id="文字" tabindex="-1">文字 <a class="header-anchor" href="#文字" aria-label="Permalink to &quot;文字&quot;">​</a></h3><p>文字是通过一些文字制作的，比如fontforge</p><p>制作文字时，会有几根参考线，不同的文字类型，参考线不一样。同一种文字类型，参考线一致。</p><img src="`+e+'"><h3 id="字体大小" tabindex="-1">字体大小 <a class="header-anchor" href="#字体大小" aria-label="Permalink to &quot;字体大小&quot;">​</a></h3><p>设置文字的相对大小</p><p>文字的相对大小:1000 2048 1024</p><h2 id="堆叠上下文-stack-context" tabindex="-1">堆叠上下文（stack context） <a class="header-anchor" href="#堆叠上下文-stack-context" aria-label="Permalink to &quot;堆叠上下文（stack context）&quot;">​</a></h2><p>是一块区域，有某个元素创建，它规定了该区域中的内容在Z轴上排列的先后顺序</p><h3 id="创建堆叠上下文的元素" tabindex="-1">创建堆叠上下文的元素 <a class="header-anchor" href="#创建堆叠上下文的元素" aria-label="Permalink to &quot;创建堆叠上下文的元素&quot;">​</a></h3><ol><li>html元素（根元素）</li><li>设置了z-index（非auto）数值的定位元素</li></ol><h3 id="同一个堆叠上下文中元素在z轴上的排列" tabindex="-1">同一个堆叠上下文中元素在z轴上的排列 <a class="header-anchor" href="#同一个堆叠上下文中元素在z轴上的排列" aria-label="Permalink to &quot;同一个堆叠上下文中元素在z轴上的排列&quot;">​</a></h3><p>从后到前的排列顺序(属同一种情况的后面元素覆盖前面元素)</p><ol><li>创建堆叠上下文的元素的背景和边框</li><li>堆叠级别为负的堆叠上下文</li><li>常规流非定位的块盒</li><li>非定位的浮动盒子</li><li>常规流非定位行盒</li><li>任何z-index是auto的定位子元素，以及z-index是0的堆叠上下文</li><li>堆叠级别为正值的堆叠上下文</li></ol><p>每个堆叠上下文，独立于其他堆叠上下文，他们之间不能相互穿插</p><h2 id="数据链接" tabindex="-1">数据链接 <a class="header-anchor" href="#数据链接" aria-label="Permalink to &quot;数据链接&quot;">​</a></h2><p>data url</p><h3 id="如何书写" tabindex="-1">如何书写 <a class="header-anchor" href="#如何书写" aria-label="Permalink to &quot;如何书写&quot;">​</a></h3><p>数据链接： 将目标文件的数据直接书写到路径位置</p><p>语法：data：MIME（数据类型）,数据</p><h3 id="意义" tabindex="-1">意义 <a class="header-anchor" href="#意义" aria-label="Permalink to &quot;意义&quot;">​</a></h3><p>优点：</p><ol><li>减少浏览器请求</li><li>有利于动态生成数据</li></ol><p>缺点：</p><ol><li>增加了资源体积</li></ol><p>导致了传输内容增加，从而增加了单个资源的传输时间</p><ol start="2"><li>不利于浏览器的缓存</li></ol><p>浏览器通常会缓存图片、CSS文件、JS文件</p><h4 id="应用场景" tabindex="-1">应用场景 <a class="header-anchor" href="#应用场景" aria-label="Permalink to &quot;应用场景&quot;">​</a></h4><ol><li><p>请求单个图片体积较小，并且该图片因为各种原因，不适合制作雪碧图，可以使用数据链接</p></li><li><p>图片由其他代码动态生成</p></li></ol><h3 id="base64" tabindex="-1">base64 <a class="header-anchor" href="#base64" aria-label="Permalink to &quot;base64&quot;">​</a></h3><p>一种编码方式</p><p>通常用于将一些二进制数据，用一个可书写的字符串表示</p>',78)]))}const u=i(n,[["render",o]]);export{b as __pageData,u as default};

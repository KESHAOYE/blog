import{_ as l,c as i,ag as e,o as r}from"./chunks/framework.BxW8Wou5.js";const t="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%84%E4%BB%B6%E7%9A%84%E5%AE%9A%E4%B9%89.png",o="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%84%E4%BB%B6%E7%9A%84%E5%A4%8D%E7%94%A8.png",n="/blog/picture/%E8%BD%AF%E8%80%83/CORBA.png",h="/blog/picture/%E8%BD%AF%E8%80%83/%E4%B8%AD%E9%97%B4%E4%BB%B6.png",m=JSON.parse('{"title":"10.构件与中间件","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/系统架构师/第5章 - 软件架构设计/10.构件与中间件.md","filePath":"ruankao/系统架构师/第5章 - 软件架构设计/10.构件与中间件.md","lastUpdated":1746770091000}'),s={name:"ruankao/系统架构师/第5章 - 软件架构设计/10.构件与中间件.md"};function d(u,a,c,b,_,p){return r(),i("div",null,a[0]||(a[0]=[e('<h1 id="_10-构件与中间件" tabindex="-1">10.构件与中间件 <a class="header-anchor" href="#_10-构件与中间件" aria-label="Permalink to &quot;10.构件与中间件&quot;">​</a></h1><h2 id="构件" tabindex="-1">构件 <a class="header-anchor" href="#构件" aria-label="Permalink to &quot;构件&quot;">​</a></h2><p>软件构件是一种组装单元，它具有规范的接口规约和显式的语境依赖。软件构件可以被独立地部署并由第三方任意的组装 构件是某个系统中有价值的、几乎独立的并可替换的一个部分，它在良好定义的体系结构语境内满足某清晰的功能 构件是一个独立发布的功能部分，可以通过其接口访问它的服务</p><img src="'+t+'"><p>构件是可独立部署的软件单元 构件没有（外部的）可见状态，但是可以通过容器管理滋生对外的可见状态</p><h3 id="复用" tabindex="-1">复用 <a class="header-anchor" href="#复用" aria-label="Permalink to &quot;复用&quot;">​</a></h3><img src="'+o+'"><h4 id="检索与提取构件" tabindex="-1">检索与提取构件 <a class="header-anchor" href="#检索与提取构件" aria-label="Permalink to &quot;检索与提取构件&quot;">​</a></h4><ul><li>基于关键字检索：在 Visio 中，每个图例是一个构件</li><li>刻面检索法：用多种方式划分（应用领域、使用环境、功能...）</li><li>超文本检索法：了解即可</li></ul><h4 id="理解与评价构件" tabindex="-1">理解与评价构件 <a class="header-anchor" href="#理解与评价构件" aria-label="Permalink to &quot;理解与评价构件&quot;">​</a></h4><ul><li>要复用构件，<strong>准确的理解构件</strong>至关重要。特别是对构件修改使用时</li><li>为达到目的，<strong>必须要求构件的开发过程遵循公共标准</strong></li><li>构件库文档中要全面、准确的说明：构件的功能和行为、相关的领域知识、可适应性约束条件与例外情况、可以预见的修改部分及修改方法</li></ul><h4 id="修改构件" tabindex="-1">修改构件 <a class="header-anchor" href="#修改构件" aria-label="Permalink to &quot;修改构件&quot;">​</a></h4><ul><li><strong>理想状态是直接复用构件库中现成的构件</strong>，但大多数情况下都要修改构件适应新需求</li><li>为了减少构件修改的工作量，开发人员要尽量使构件的功能、行为和接口设计更加抽象化、通用化和参数化。复用者可以通过对实参的选取来调整构件的功能或行为。如果还是不满足，复用者要借助设计信息和文档来修改构件。</li><li>如果构件库中没有可修改使用的构件，则按新需求开发构件，并存入构件库。</li></ul><h4 id="组装构件" tabindex="-1">组装构件 <a class="header-anchor" href="#组装构件" aria-label="Permalink to &quot;组装构件&quot;">​</a></h4><h5 id="三种方式" tabindex="-1">三种方式 <a class="header-anchor" href="#三种方式" aria-label="Permalink to &quot;三种方式&quot;">​</a></h5><ul><li>基于功能的组装：采用子程序调用和参数传递的方式将构件组装起来</li><li>基于数据的组装：仍然是传统的子程序调用与参数传递。但它所依赖的软件设计方法不再是功能分解，而是面向数据的设计方法</li><li>面向对象的组装：如果从类库中检索出来的基类能够完全满足新系统的需求，则可以直接应用。否则，必须以基类为父类，生成相应的子类，以满足新系统的需求</li></ul><h5 id="构件组装失配的问题" tabindex="-1">构件组装失配的问题 <a class="header-anchor" href="#构件组装失配的问题" aria-label="Permalink to &quot;构件组装失配的问题&quot;">​</a></h5><ul><li>由构件引起的失配，包括由于系统对构件基础设施、构件控制模型和构件数据模型的假设存在冲突引起的失配 说人话：构件自身的设计和实现出问题了，数据格式不兼容、接口不兼容、假设不一致、资源管理冲突等</li><li>由连接子引起的失配，包括由于系统对构件交互协议、连接子数据模型的假设存在冲突引起的失配 说人话：构件间的通信、协调、转换出了问题，连接协议不匹配、数据转换错误、寻址和绑定问题等</li><li>由于系统成分对全局体系结构的假设存在冲突引起的失配等。要解决失配问题，首先需要检测出失配问题，并在此基础上通过适当的手段消除检测出失配的问题</li></ul><h3 id="构件的分类" tabindex="-1">构件的分类 <a class="header-anchor" href="#构件的分类" aria-label="Permalink to &quot;构件的分类&quot;">​</a></h3><h4 id="外部形态来看-外观-构件展示的部分" tabindex="-1">外部形态来看（外观，构件展示的部分） <a class="header-anchor" href="#外部形态来看-外观-构件展示的部分" aria-label="Permalink to &quot;外部形态来看（外观，构件展示的部分）&quot;">​</a></h4><ul><li>独立而成熟的构件：已在实际运行环境多次检验，该类构件<strong>隐藏了所有接口</strong>,用户只需用规定好的命令进行使用。 例如：数据库管理系统和操作系统等</li><li>有限制的构件：有限制构件提供了接口，指出了使用的前提和条件，这种构件在装配时，<strong>会产生资源冲突、覆盖等影响</strong>，在使用时需要记忆测试。例如：各种面向对象程序设计语言中的基础类库。</li><li>适应性构件：进行了包装或使用了接口技术。把不兼容性、资源冲突等进行了处理，可以直接使用。这种构件可以不加修改的使用在各种环境中。例如 ACTIVEX</li><li>装配的构件：在安装时，已经装配在操作系统、数据库管理系统或信息系统不同层次上，使用胶水代码就可以连接使用。目前一些软件商提供的大多数软件产品都属于这一类。</li><li>可修改的构件：对原构件修改错误、增加新功能，可以利用重新“包装”或写接口来实现构件版本的替换。这种构件在应用系统开发中使用的比较多</li></ul><h3 id="构件的标准" tabindex="-1">构件的标准 <a class="header-anchor" href="#构件的标准" aria-label="Permalink to &quot;构件的标准&quot;">​</a></h3><p>有标准才好复用</p><ul><li>会话 Bean：<strong>实现业务逻辑</strong>,负责完成客户端与服务端的交互</li><li>实体 Bean：<strong>实现 O/R 映射</strong>,简化数据库开发工作</li><li>消息驱动 Bean：<strong>处理并发与异常访问</strong></li></ul><h4 id="corba" tabindex="-1">CORBA <a class="header-anchor" href="#corba" aria-label="Permalink to &quot;CORBA&quot;">​</a></h4><img src="'+n+'"><p>解决了远程通信、调用的问题（客户端调用远程服务器对象）</p><ul><li>伺服对象（在服务器上）：CORBA 真正的实现，负责完成客户端的请求</li><li>对象适配器(在服务端)：用于屏蔽 ORB 内核的实现细节，为服务器对象的实现者提供抽象接口，以便他们使用 ORB 内部的某些功能</li><li>对象请求代理：解释调用并负责查找实现该请求的对象，将参数传给找到的对象，并调用方法返回结果。客户方不需要了解服务对象的位置、通信方式、实现、激活或存储机制。</li></ul><h4 id="j2ee【ejb】" tabindex="-1">J2EE【EJB】 <a class="header-anchor" href="#j2ee【ejb】" aria-label="Permalink to &quot;J2EE【EJB】&quot;">​</a></h4><h4 id="dna2000" tabindex="-1">DNA2000 <a class="header-anchor" href="#dna2000" aria-label="Permalink to &quot;DNA2000&quot;">​</a></h4><h2 id="中间件" tabindex="-1">中间件 <a class="header-anchor" href="#中间件" aria-label="Permalink to &quot;中间件&quot;">​</a></h2><p>是构件的一种</p><p>中间件是一类系统软件（为别的软件服务，应用软件为人服务）</p><img src="'+h+'"><p><strong>JDBC</strong>是一种中间件</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>面向需求：设计师集中精力于业务逻辑本身</li><li>业务的分隔和包容性：应用开发人员可以按照不同的业务进行功能的划分，体现为不同的接口或交互模式</li><li>设计与实现的隔离：构件对外发生作用或构件间的交互，都是通过接口进行的，构件使用者只需要知道构件的接口，而不必关心其内部的实现，这是设计与实现分离的关键</li><li>隔离复杂的系统资源：架构很重要的一个功能就是将系统资源和应用构件隔离，这是保证构件可复用甚至“即插即用”的基础，与中间件的意图也是一致的。</li><li>符合标准的交互模型：中间件则实现了架构的模型，实现了标准的协议。</li><li>软件复用：中间件提供了构件封装、交互规则、与环境的隔离等机制，这些都为软件复用提供了方便的解决方案</li><li>提供对应用构件的管理：基于中间件的软件可以方便的进行管理，因为构件总可以通过标识机制进行划分。</li></ul><h3 id="分类" tabindex="-1">分类 <a class="header-anchor" href="#分类" aria-label="Permalink to &quot;分类&quot;">​</a></h3><ul><li>通信处理（消息）中间件 - 多个平台通信：可靠、高效、实时跨平台通信，elink，MQSeries</li><li>事务处理（交易）中间件 - 集群（多个服务器）：事务分发，负载均衡，Tuxedo</li><li>数据存区管理中间件：为虚拟缓冲存取、格式转换、解压等带来方便</li><li>WEB 服务器中间件 - 接收 WEB 请求、传送：有负载均衡、缓存、安全性等功能</li><li>安全中间件：加密、认证等</li><li>跨平台和架构的中间件：解决跨平台问题，如 CORBA</li><li>专用平台中间件：为特定应用领域设计领域参考模式，建立相应架构</li><li>网络中间件：功能包括网管、接入、网络测试、虚拟社区和虚拟缓冲等</li></ul>',39)]))}const E=l(s,[["render",d]]);export{m as __pageData,E as default};

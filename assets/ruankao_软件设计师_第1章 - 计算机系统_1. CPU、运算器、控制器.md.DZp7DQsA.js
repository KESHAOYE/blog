import{_ as e,c as r,ag as t,o}from"./chunks/framework.BxW8Wou5.js";const P=JSON.parse('{"title":"1、CPU、运算器、控制器","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/软件设计师/第1章 - 计算机系统/1. CPU、运算器、控制器.md","filePath":"ruankao/软件设计师/第1章 - 计算机系统/1. CPU、运算器、控制器.md","lastUpdated":null}'),l={name:"ruankao/软件设计师/第1章 - 计算机系统/1. CPU、运算器、控制器.md"};function i(n,a,h,d,s,c){return o(),r("div",null,a[0]||(a[0]=[t('<h1 id="_1、cpu、运算器、控制器" tabindex="-1">1、CPU、运算器、控制器 <a class="header-anchor" href="#_1、cpu、运算器、控制器" aria-label="Permalink to &quot;1、CPU、运算器、控制器&quot;">​</a></h1><h2 id="运算器" tabindex="-1">运算器 <a class="header-anchor" href="#运算器" aria-label="Permalink to &quot;运算器&quot;">​</a></h2><h3 id="alu-算术逻辑单元" tabindex="-1">ALU（算术逻辑单元） <a class="header-anchor" href="#alu-算术逻辑单元" aria-label="Permalink to &quot;ALU（算术逻辑单元）&quot;">​</a></h3><p>是运算器的<strong>重要</strong>组成部分，负责处理数据，实现对数据的算术运算和逻辑运算。 <strong>加法器是部件</strong></p><h3 id="ac-累加寄存器" tabindex="-1">AC（累加寄存器） <a class="header-anchor" href="#ac-累加寄存器" aria-label="Permalink to &quot;AC（累加寄存器）&quot;">​</a></h3><p>功能是当 ALU 执行算数或逻辑运算时，为 ALU 提供工作区。运算的结果存放在此，运算器中至少要有一个累加寄存器。</p><h2 id="控制器" tabindex="-1">控制器 <a class="header-anchor" href="#控制器" aria-label="Permalink to &quot;控制器&quot;">​</a></h2><p>运算器只能完成运算，但是控制器用于控制整个 CPU 的工作，它决定了计算机运行过程的自动化。它不仅要保证程序的正确执行，还要能<strong>处理异常事件</strong></p><h3 id="指令寄存器-ir" tabindex="-1">指令寄存器（IR） <a class="header-anchor" href="#指令寄存器-ir" aria-label="Permalink to &quot;指令寄存器（IR）&quot;">​</a></h3><p>当 CPU 执行一条指令时，先把它从内存储器中取到缓冲寄存器中，再送入 IR 暂存，指令译码器（ID）根据 IR 的内容产生各种微操作指令，控制其他的组成部件工作，完成所需的功能。</p><h4 id="做题启示" tabindex="-1">做题启示 <a class="header-anchor" href="#做题启示" aria-label="Permalink to &quot;做题启示&quot;">​</a></h4><ul><li>对用户透明</li></ul><h3 id="程序计数器-pc" tabindex="-1">程序计数器（PC） <a class="header-anchor" href="#程序计数器-pc" aria-label="Permalink to &quot;程序计数器（PC）&quot;">​</a></h3><p>PC 具有寄存信息和计数两种功能。程序的执行分为顺序执行和转移执行。程序开始执行前，将<strong>程序的起始地址</strong>送入 PC，该地址在程序加载到内存时确定，因此 PC 的内容时程序第一条指令的地址。执行指令时，CPU 自动修改 PC 的内容，以便其保持的总是将要执行的下一条指令的地址，顺序执行的话，修改过程基本是简单的加一。</p><h3 id="地址寄存器-ar" tabindex="-1">地址寄存器（AR） <a class="header-anchor" href="#地址寄存器-ar" aria-label="Permalink to &quot;地址寄存器（AR）&quot;">​</a></h3><p>AR 保存当前 CPU 所访问的内存单元的地址。由于内存和 CPU 存在着操作速度上的差异，所以要用 AR 保持地址信息，直到内存完成读/写操作。</p><h4 id="做题启示-1" tabindex="-1">做题启示 <a class="header-anchor" href="#做题启示-1" aria-label="Permalink to &quot;做题启示&quot;">​</a></h4><ul><li>保存的是 CPU 所访问的内存地址，指令地址保存在 PC</li></ul><h3 id="指令译码器-id" tabindex="-1">指令译码器（ID） <a class="header-anchor" href="#指令译码器-id" aria-label="Permalink to &quot;指令译码器（ID）&quot;">​</a></h3><p>指令包含地址码和操作码。为了能执行任何给定的指令，必须对操作码进行分析，以便识别所完成的操作。指令译码器就是对指令中的操作码字段进行分析解释，识别改指令规定的操作，像操作控制器发出具体的控制信号，控制哥部件工作，完成所需的功能。</p><h4 id="做题启示-2" tabindex="-1">做题启示 <a class="header-anchor" href="#做题启示-2" aria-label="Permalink to &quot;做题启示&quot;">​</a></h4><ul><li>操作码和地址码（整条指令）都存入指令译码器</li><li>主要作用是指令译码</li></ul>',22)]))}const _=e(l,[["render",i]]);export{P as __pageData,_ as default};

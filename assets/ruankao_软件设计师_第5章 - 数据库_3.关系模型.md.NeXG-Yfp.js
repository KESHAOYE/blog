import{_ as i,c as t,ag as e,j as a,a as r,o}from"./chunks/framework.BxW8Wou5.js";const m=JSON.parse('{"title":"3、关系模式","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/软件设计师/第5章 - 数据库/3.关系模型.md","filePath":"ruankao/软件设计师/第5章 - 数据库/3.关系模型.md","lastUpdated":null}'),h={name:"ruankao/软件设计师/第5章 - 数据库/3.关系模型.md"};function n(d,l,s,u,c,q){return o(),t("div",null,l[0]||(l[0]=[e('<h1 id="_3、关系模式" tabindex="-1">3、关系模式 <a class="header-anchor" href="#_3、关系模式" aria-label="Permalink to &quot;3、关系模式&quot;">​</a></h1><h2 id="常用术语" tabindex="-1">常用术语 <a class="header-anchor" href="#常用术语" aria-label="Permalink to &quot;常用术语&quot;">​</a></h2><ul><li>关系：一个关系就是一张二维表，每个关系有一个关系名</li><li>元组：表中的一行是一个元组，对应存储文件中的一个记录值</li><li>属性：表中的列称为属性，每一列有一个属性名，属性值相当于记录中的数据项或字段值</li><li>域：属性的取值范围，即不同元组对同一个属性的值限定的范围，例如逻辑型属性只认真（T）假（F）</li><li>关系模式：对关系的描述称为关系模式，由关系名和其属性集合构成</li></ul><blockquote><p>关系模式的格式为：关系名（属性 1，属性 2，属性 3，...）</p></blockquote><h2 id="五个码" tabindex="-1">五个码 <a class="header-anchor" href="#五个码" aria-label="Permalink to &quot;五个码&quot;">​</a></h2><ul><li>候选码：属性或<strong>属性组合</strong>，其值能够唯一地标识一个元组</li><li>主码（主键）：在一个关系中可能有多个候选码，从中选择一个作为主码</li><li>主属性：包含在任何候选码的属性称为主属性，不包含的称为非主属性</li><li>外码（外键）：一个关系中的属性或属性组并非改关系的码，但是是另外一个关系的码，称为该关系的外码</li><li>全码：关系模式中的所有属性组是这个关系模式的候选码，称为全码</li><li>超码：一个包含码的属性集称为超码，例如学号是码，则（学号、姓名）是超码</li></ul><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><ul><li>关系的描述称为关系模式，可以表示为 R（U - 属性集合、D - 属性 D 中来自的域、dom、F）</li><li>通常简记为 R（a1，a2，...，aN）</li><li>关系模型中数据的逻辑关系是<strong>一张二维表</strong></li></ul><h2 id="完整性约束" tabindex="-1">完整性约束 <a class="header-anchor" href="#完整性约束" aria-label="Permalink to &quot;完整性约束&quot;">​</a></h2><ul><li>实体完整性：关系中主码不能为空</li><li>参照完整性：外键（可以为空）必须在对应的关系中找到（不能为空值）</li></ul><h2 id="关系代数运算符" tabindex="-1">关系代数运算符 <a class="header-anchor" href="#关系代数运算符" aria-label="Permalink to &quot;关系代数运算符&quot;">​</a></h2><h3 id="集合运算符" tabindex="-1">集合运算符 <a class="header-anchor" href="#集合运算符" aria-label="Permalink to &quot;集合运算符&quot;">​</a></h3><h4 id="并-u-不考" tabindex="-1">并（U）- 不考 <a class="header-anchor" href="#并-u-不考" aria-label="Permalink to &quot;并（U）- 不考&quot;">​</a></h4><p>关系 R 和关系 S 的所有元组合并，再删除重复的元组，组成一个新关系，称为 R 和 S</p><h4 id="交-n-不考" tabindex="-1">交（n）- 不考 <a class="header-anchor" href="#交-n-不考" aria-label="Permalink to &quot;交（n）- 不考&quot;">​</a></h4><p>关系 R 和关系 S 的交，是即属于 R 又属于 S 的元组组成的集合</p><h4 id="差-不考" tabindex="-1">差（-）- 不考 <a class="header-anchor" href="#差-不考" aria-label="Permalink to &quot;差（-）- 不考&quot;">​</a></h4><p>R 和 S 的差，是属于 R 但不属于 S 的元组组成的集合</p><h4 id="笛卡尔积-x" tabindex="-1">笛卡尔积（x） <a class="header-anchor" href="#笛卡尔积-x" aria-label="Permalink to &quot;笛卡尔积（x）&quot;">​</a></h4>',19),a("p",{"(0,a),(0,b),(0,c),(1,a),(1,b),(1,c)":""},"例如 D1= {0,1}, D2 = {a,b,c} 则 D1 x D2 =",-1),e('<h3 id="专门的关系运算符" tabindex="-1">专门的关系运算符 <a class="header-anchor" href="#专门的关系运算符" aria-label="Permalink to &quot;专门的关系运算符&quot;">​</a></h3><h4 id="选择-σ" tabindex="-1">选择（σ） <a class="header-anchor" href="#选择-σ" aria-label="Permalink to &quot;选择（σ）&quot;">​</a></h4><ul><li>从关系的水平方向进行运算，从关系 R 中选出满足条件的元组</li><li>记为 σF（R）</li><li>F 中的运算对象是属性名或常数，运算符、算术比较符和逻辑运算符</li><li>要比较数值，要加单引号，不加单引号就是列的序号</li></ul><h4 id="投影-π" tabindex="-1">投影（π） <a class="header-anchor" href="#投影-π" aria-label="Permalink to &quot;投影（π）&quot;">​</a></h4><p>从关系的垂直方向进行运算，从关系 R 中选出若干属性列 A 组成新的关系 说人话：选几列组成新的关系</p><h4 id="连接-⨝" tabindex="-1">连接（⨝） <a class="header-anchor" href="#连接-⨝" aria-label="Permalink to &quot;连接（⨝）&quot;">​</a></h4><p>连接运算是从笛卡尔积中选择符合条件的元组</p><h5 id="θ-连接" tabindex="-1">θ 连接 <a class="header-anchor" href="#θ-连接" aria-label="Permalink to &quot;θ 连接&quot;">​</a></h5><p>从 R 与 S 的笛卡尔积中选择符合条件的元组，θ 为符号（算术比较、逻辑运算）</p><p>可以换算为 σxθy（RxS）</p><h5 id="等值连接" tabindex="-1">等值连接 <a class="header-anchor" href="#等值连接" aria-label="Permalink to &quot;等值连接&quot;">​</a></h5><p>当 θ 为“=”时，称为等值连接</p><h5 id="自然连接" tabindex="-1">自然连接 <a class="header-anchor" href="#自然连接" aria-label="Permalink to &quot;自然连接&quot;">​</a></h5><ul><li>是去除重复属性的等值连接（笛卡尔积后 θ 为“=”）</li><li>关系 R 和 S，有一个或多个同名属性</li><li>自然连接为空，退化成笛卡尔积</li><li>计算过程为： <ol><li>计算 R x S</li><li>设 R 和 S 的公共属性为 A1....AK，挑选 RxS 中符合 R.A1 = S.A1...R.Ak = S.Ak 的元组(所有的公共属性列都要相等)</li><li>去掉 SA1...SAk 这些列（保留 R.A1...R.Ak 列）</li></ol></li></ul><h5 id="外连接" tabindex="-1">外连接 <a class="header-anchor" href="#外连接" aria-label="Permalink to &quot;外连接&quot;">​</a></h5><p>是连接运算的拓展，可以处理由于连接运算而缺失的信息</p><h6 id="左外连接-连接符号左边加两条杠" tabindex="-1">左外连接（连接符号左边加两条杠） <a class="header-anchor" href="#左外连接-连接符号左边加两条杠" aria-label="Permalink to &quot;左外连接（连接符号左边加两条杠）&quot;">​</a></h6><p>讲人话就是将自然连接删除的数据加入到关系中，但是右表中的属性设为空值</p><h6 id="右外连接-连接符号右边加两条杠" tabindex="-1">右外连接（连接符号右边加两条杠） <a class="header-anchor" href="#右外连接-连接符号右边加两条杠" aria-label="Permalink to &quot;右外连接（连接符号右边加两条杠）&quot;">​</a></h6><p>讲人话就是将自然连接删除的数据加入到关系中，但是左表中的属性设为空值</p><h6 id="全外连接-连接符号左右边各加两条杠" tabindex="-1">全外连接（连接符号左右边各加两条杠） <a class="header-anchor" href="#全外连接-连接符号左右边各加两条杠" aria-label="Permalink to &quot;全外连接（连接符号左右边各加两条杠）&quot;">​</a></h6><p>自然连接 + 左外连接 + 右外连接</p><h4 id="除-➗-不考" tabindex="-1">除（➗） - 不考 <a class="header-anchor" href="#除-➗-不考" aria-label="Permalink to &quot;除（➗） - 不考&quot;">​</a></h4><h2 id="关系代数转-sql-语言" tabindex="-1">关系代数转 SQL 语言 <a class="header-anchor" href="#关系代数转-sql-语言" aria-label="Permalink to &quot;关系代数转 SQL 语言&quot;">​</a></h2><h3 id="投影转-sql" tabindex="-1">投影转 SQL <a class="header-anchor" href="#投影转-sql" aria-label="Permalink to &quot;投影转 SQL&quot;">​</a></h3><ul><li>转换为<code>select from</code></li></ul><h3 id="选择转-sql" tabindex="-1">选择转 SQL <a class="header-anchor" href="#选择转-sql" aria-label="Permalink to &quot;选择转 SQL&quot;">​</a></h3><ul><li>转换为<code>select from where</code></li></ul><h3 id="笛卡尔积转-sql" tabindex="-1">笛卡尔积转 SQL <a class="header-anchor" href="#笛卡尔积转-sql" aria-label="Permalink to &quot;笛卡尔积转 SQL&quot;">​</a></h3><ul><li>转换为<code>select 所有列 from R，S where</code></li></ul><h3 id="自然连接转-sql" tabindex="-1">自然连接转 SQL <a class="header-anchor" href="#自然连接转-sql" aria-label="Permalink to &quot;自然连接转 SQL&quot;">​</a></h3><ul><li>转换为<code>select 所有列 from R，S where R.列名 = S.列名 and R.列名 = S.列名</code></li></ul><h2 id="五元组" tabindex="-1">五元组 <a class="header-anchor" href="#五元组" aria-label="Permalink to &quot;五元组&quot;">​</a></h2><p>一个关系模式应该是一个五元组</p><p><code>R&lt;U，D，dom，F&gt;</code></p><ul><li>R: 关系名</li><li>U：一组属性</li><li>D：属性 U 的取值范围</li><li>dom：属性到域的映射</li><li>F：属性组 U 上的一组数据依赖（函数依赖）</li></ul><h3 id="函数依赖" tabindex="-1">函数依赖 <a class="header-anchor" href="#函数依赖" aria-label="Permalink to &quot;函数依赖&quot;">​</a></h3><ul><li>X 函数决定 Y，Y 函数依赖于 X，记作 X-&gt;Y</li><li>比如 学号 -&gt; 姓名（学号决定姓名）</li><li>非平凡的函数依赖（大部分情况），如果 X-&gt;Y，但 Y 不包含于 X，则称 X-&gt;Y 为非平凡的函数依赖</li><li>平凡的函数依赖：如果 X-&gt;Y，且 Y 包含于 X，则称 X-&gt;Y 为平凡的函数依赖</li><li><strong>完全函数依赖</strong>：如果 X-&gt;Y，且 X 中任意一个真子集都不能决定 Y，则称为完全函数依赖，记作 X-(F)-&gt;Y</li><li>部分函数依赖：如果 X-&gt;Y，且 X 中任意一个真子集可以决定 Y，则称为部分函数依赖，记作 X-(P)-&gt;Y</li><li><strong>传递依赖</strong>：如果 X-&gt;Y，Y 不包含 X，Y-&gt;Z，则称 Z 对 X 传递依赖</li></ul><h4 id="公理系统" tabindex="-1">公理系统 <a class="header-anchor" href="#公理系统" aria-label="Permalink to &quot;公理系统&quot;">​</a></h4><ul><li>A1 自反律：若 Y 属于 X 属于 U，则 X-&gt;Y 为 F 所蕴含</li><li>A2 增广率：若 X-&gt;Y，Y-&gt;Z，且 Z 包含于 U，则 XZ -&gt; YZ 为 F 所蕴含</li><li><strong>A3 传递律</strong>：若 X-&gt;Y，Y-&gt;Z，则 X-&gt;Z 为 F 所蕴含</li><li><strong>合并规则</strong>：若 X-&gt;Y，X-&gt;Z，则 X-&gt;YZ 为 F 所蕴含</li><li>伪传递率：若 X-&gt;Y，WY-&gt;Z，则 XW-&gt;Z 为 F 所蕴含</li><li><strong>分解规则</strong>：若 X-&gt;Y，Z 包含于 Y，则 X-&gt;Z 为 F 所蕴含</li></ul><h2 id="属性闭包原则" tabindex="-1">属性闭包原则 <a class="header-anchor" href="#属性闭包原则" aria-label="Permalink to &quot;属性闭包原则&quot;">​</a></h2>',41),a("ul",null,[a("li",null,[a("blockquote",null,[a("p",{"A-B,B-DH,A-H,C-E":""},"给定关系 R(U,F)，其中 U = {A,B,C,D,E,H},F=")])])],-1),a("p",null,"{A,C} -> {A,B,C,H,E} -> {A,B,C,D,H,E} =U",-1),a("h3",{id:"如何挑选候选键",tabindex:"-1"},[r("如何挑选候选键 "),a("a",{class:"header-anchor",href:"#如何挑选候选键","aria-label":'Permalink to "如何挑选候选键"'},"​")],-1),a("ul",null,[a("li",null,"不挑箭头右边，挑选箭头左边"),a("li",null,"要选择不能被其他属性决定的")],-1)]))}const x=i(h,[["render",n]]);export{m as __pageData,x as default};

import{_ as l,c as i,ag as e,o as r}from"./chunks/framework.BxW8Wou5.js";const f=JSON.parse('{"title":"6、范式（1NF、2NF、3NF、BCNF、4NF、5NF）","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/软件设计师/第5章 - 数据库/6.范式.md","filePath":"ruankao/软件设计师/第5章 - 数据库/6.范式.md","lastUpdated":null}'),t={name:"ruankao/软件设计师/第5章 - 数据库/6.范式.md"};function n(o,a,h,s,u,d){return r(),i("div",null,a[0]||(a[0]=[e('<h1 id="_6、范式-1nf、2nf、3nf、bcnf、4nf、5nf" tabindex="-1">6、范式（1NF、2NF、3NF、BCNF、4NF、5NF） <a class="header-anchor" href="#_6、范式-1nf、2nf、3nf、bcnf、4nf、5nf" aria-label="Permalink to &quot;6、范式（1NF、2NF、3NF、BCNF、4NF、5NF）&quot;">​</a></h1><p>与候选码和主码有关</p><p><strong>判断范式的第一步就是求出候选码，然后区分出主属性和非主属性</strong></p><h2 id="第一范式-软考中基本都符合" tabindex="-1">第一范式（软考中基本都符合） <a class="header-anchor" href="#第一范式-软考中基本都符合" aria-label="Permalink to &quot;第一范式（软考中基本都符合）&quot;">​</a></h2><ul><li>满足最低要求的称为第一范式</li><li>关系 R 中的每个属性 A 的值只包含原子项目（即不可分割的数据项）</li><li>不能排除数据冗余和更新异常，因为可能可能存在对候选码的<strong>部分函数依赖</strong></li></ul><h3 id="数据冗余和更新异常" tabindex="-1">数据冗余和更新异常 <a class="header-anchor" href="#数据冗余和更新异常" aria-label="Permalink to &quot;数据冗余和更新异常&quot;">​</a></h3><ul><li>重复出现的不必要的数据就是数据冗余</li><li>修改异常：问题基于数据冗余</li><li>插入异常：本来可以插入的数据，现在插入不了</li></ul><h2 id="第二范式" tabindex="-1">第二范式 <a class="header-anchor" href="#第二范式" aria-label="Permalink to &quot;第二范式&quot;">​</a></h2><ul><li>满足第一范式后，每个非主属性都<strong>完全函数依赖</strong>于候选码</li><li>第二范式也可能存在数据冗余和更新异常，因为其中可能<strong>存在对候选码的传递依赖</strong></li></ul><h3 id="分解第一范式的问题" tabindex="-1">分解第一范式的问题 <a class="header-anchor" href="#分解第一范式的问题" aria-label="Permalink to &quot;分解第一范式的问题&quot;">​</a></h3><ul><li>将原来存储在一个二维表中的数据分散到多个二维表中（一张表拆成多张表）</li><li>最低要求是不能丢失前者的信息</li></ul><h2 id="第三范式" tabindex="-1">第三范式 <a class="header-anchor" href="#第三范式" aria-label="Permalink to &quot;第三范式&quot;">​</a></h2><ul><li>满足第二范式后，每个非主属性都<strong>非传递依赖</strong>于候选码</li><li>可能存在主属性对码的部分依赖和传递依赖</li></ul><h3 id="分解第二范式的问题" tabindex="-1">分解第二范式的问题 <a class="header-anchor" href="#分解第二范式的问题" aria-label="Permalink to &quot;分解第二范式的问题&quot;">​</a></h3><ul><li>继续拆表</li><li>可以删除掉部分的函数依赖</li></ul><h2 id="bc-范式" tabindex="-1">BC 范式 <a class="header-anchor" href="#bc-范式" aria-label="Permalink to &quot;BC 范式&quot;">​</a></h2><ul><li>所有非主属性对每一个码都是完全函数依赖</li><li>所有的主属性对每一个不包含他的码，也是完全函数依赖</li><li>没有任何属性完全依赖于非码的任何一组属性</li><li>完全消除插入、删除异常</li></ul><h3 id="消除第三范式中的问题" tabindex="-1">消除第三范式中的问题 <a class="header-anchor" href="#消除第三范式中的问题" aria-label="Permalink to &quot;消除第三范式中的问题&quot;">​</a></h3><h2 id="无损连接" tabindex="-1">无损连接 <a class="header-anchor" href="#无损连接" aria-label="Permalink to &quot;无损连接&quot;">​</a></h2><ul><li>自然连接后和原来一致</li></ul>',20)]))}const _=l(t,[["render",n]]);export{f as __pageData,_ as default};

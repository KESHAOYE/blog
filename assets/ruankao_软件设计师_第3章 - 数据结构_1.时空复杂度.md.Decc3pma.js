import{_ as l,c as e,ag as r,o as i}from"./chunks/framework.BxW8Wou5.js";const p=JSON.parse('{"title":"1、时空复杂度","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/软件设计师/第3章 - 数据结构/1.时空复杂度.md","filePath":"ruankao/软件设计师/第3章 - 数据结构/1.时空复杂度.md","lastUpdated":null}'),t={name:"ruankao/软件设计师/第3章 - 数据结构/1.时空复杂度.md"};function o(n,a,s,u,h,d){return i(),e("div",null,a[0]||(a[0]=[r('<h1 id="_1、时空复杂度" tabindex="-1">1、时空复杂度 <a class="header-anchor" href="#_1、时空复杂度" aria-label="Permalink to &quot;1、时空复杂度&quot;">​</a></h1><h2 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h2><ul><li>以算法中基本操作重复执行的次数（简称为频度）作为算法的时间度量。一般不需要精确计算，只要<strong>大致算出相应的数量级即可</strong></li></ul><h2 id="大-o-表示法" tabindex="-1">大 O 表示法 <a class="header-anchor" href="#大-o-表示法" aria-label="Permalink to &quot;大 O 表示法&quot;">​</a></h2><ul><li>O(n<sup>n</sup>) : n 次方阶</li><li>O(n!)：阶乘阶</li><li>O(2<sup>n</sup>)：指数阶</li><li>O(n<sup>3</sup>)：立方阶：三层 for 循环</li><li>O(n<sup>2</sup>)：平方阶：两层 for 循环</li><li>O(nlog2n)：线性对数阶：</li><li>O(n)：线性阶:单层 for 循环体</li><li>O(log2n)：对数阶：a<sup>x</sup> = b -&gt; x = logab</li><li>O(1)：常数阶：<strong>和问题规模无关</strong></li></ul><h3 id="加法规则" tabindex="-1">加法规则 <a class="header-anchor" href="#加法规则" aria-label="Permalink to &quot;加法规则&quot;">​</a></h3><p>多项相加，保留最高阶项，并将系数化为 1</p><h3 id="乘法规则" tabindex="-1">乘法规则 <a class="header-anchor" href="#乘法规则" aria-label="Permalink to &quot;乘法规则&quot;">​</a></h3><p>多项相乘都保留，系数化为 1</p><h3 id="加法乘法混合规则" tabindex="-1">加法乘法混合规则 <a class="header-anchor" href="#加法乘法混合规则" aria-label="Permalink to &quot;加法乘法混合规则&quot;">​</a></h3><p>小括号再乘法规则最后加法规则</p><h2 id="空间复杂度" tabindex="-1">空间复杂度 <a class="header-anchor" href="#空间复杂度" aria-label="Permalink to &quot;空间复杂度&quot;">​</a></h2><ul><li>和问题规模相关</li><li>和变量定义的数量有关</li></ul>',13)]))}const c=l(t,[["render",o]]);export{p as __pageData,c as default};

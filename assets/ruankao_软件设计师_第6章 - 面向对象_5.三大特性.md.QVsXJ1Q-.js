import{_ as l,c as i,ag as e,o as t}from"./chunks/framework.BxW8Wou5.js";const c=JSON.parse('{"title":"5、面向对象的三大特性","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/软件设计师/第6章 - 面向对象/5.三大特性.md","filePath":"ruankao/软件设计师/第6章 - 面向对象/5.三大特性.md","lastUpdated":null}'),r={name:"ruankao/软件设计师/第6章 - 面向对象/5.三大特性.md"};function o(n,a,h,d,s,u){return t(),i("div",null,a[0]||(a[0]=[e('<h1 id="_5、面向对象的三大特性" tabindex="-1">5、面向对象的三大特性 <a class="header-anchor" href="#_5、面向对象的三大特性" aria-label="Permalink to &quot;5、面向对象的三大特性&quot;">​</a></h1><h2 id="封装" tabindex="-1">封装 <a class="header-anchor" href="#封装" aria-label="Permalink to &quot;封装&quot;">​</a></h2><ul><li>一个对象把属性和行为封装为一个整体</li><li>封装是一种信息隐蔽技术</li><li>目的是使对象的使用者和生产者分离</li><li>从程序开发者来看，对象是一个程序模块；从用户来看，对象为他们提供了所希望的行为。</li><li>一般提供 getter 和 setter 方法来获取和修改属性</li></ul><h2 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-label="Permalink to &quot;继承&quot;">​</a></h2><ul><li>是父类和子类之间共享数据和方法（非私有化）的机制</li><li>在定义和实现一个类的时候，可以在父类的基础上进行（把父类的内容作为子类的内容并加入新的内容）</li><li>子类继承一个父类叫单重继承，继承多个父类叫多重继承</li></ul><h2 id="多态" tabindex="-1">多态 <a class="header-anchor" href="#多态" aria-label="Permalink to &quot;多态&quot;">​</a></h2><ul><li>不同对象收到同一消息可以产生完全不同的结果</li><li>受到继承的支持，利用类的继承的层次关系，把通用功能的消息放在高层次，不同实现的放在低层次</li><li>父类名 对象名 = new 子类名</li><li>编译看左边，运行看右边</li></ul><h3 id="形式" tabindex="-1">形式 <a class="header-anchor" href="#形式" aria-label="Permalink to &quot;形式&quot;">​</a></h3><ul><li>参数多态：应用广泛，是最纯的多态</li><li>包含多态：子类型化</li><li>过载多态：同一个名字在不同的上下文中所代表的含义不同</li></ul><h3 id="动态绑定和静态绑定" tabindex="-1">动态绑定和静态绑定 <a class="header-anchor" href="#动态绑定和静态绑定" aria-label="Permalink to &quot;动态绑定和静态绑定&quot;">​</a></h3><ul><li>编译为静态绑定</li><li>运行的时候为动态绑定</li><li>编译看左边，运行看右边</li></ul>',11)]))}const m=l(r,[["render",o]]);export{c as __pageData,m as default};

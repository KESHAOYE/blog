import{_ as s,c as a,ag as n,o as p}from"./chunks/framework.BxW8Wou5.js";const d=JSON.parse('{"title":"9. 介绍vue2中的mixins和vue3的composition api的用法、区别等","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue/9.mixin和hook.md","filePath":"interview/vue/9.mixin和hook.md","lastUpdated":1705937785000}'),t={name:"interview/vue/9.mixin和hook.md"};function l(h,i,e,o,k,r){return p(),a("div",null,i[0]||(i[0]=[n(`<h1 id="_9-介绍vue2中的mixins和vue3的composition-api的用法、区别等" tabindex="-1">9. 介绍vue2中的mixins和vue3的composition api的用法、区别等 <a class="header-anchor" href="#_9-介绍vue2中的mixins和vue3的composition-api的用法、区别等" aria-label="Permalink to &quot;9. 介绍vue2中的mixins和vue3的composition api的用法、区别等&quot;">​</a></h1><h2 id="什么是mixins和composition-api" tabindex="-1">什么是mixins和composition api <a class="header-anchor" href="#什么是mixins和composition-api" aria-label="Permalink to &quot;什么是mixins和composition api&quot;">​</a></h2><h3 id="mixins" tabindex="-1">mixins <a class="header-anchor" href="#mixins" aria-label="Permalink to &quot;mixins&quot;">​</a></h3><p>mixins是一种在Vue组件中分发可复用功能的灵活方式。一个mixins对象可以包含任意的组件选项，当一个组件使用一个mixins时，所有mixins的选项将被“混合”进入该组件自身的选项。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义一个混入对象</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myMixin </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  created</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  methods: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    hello</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello from mixin!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 定义一个使用混入对象的组件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Component </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">extend</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  mixins: [myMixin]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> component </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Component</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// =&gt; &quot;hello from mixin!&quot;</span></span></code></pre></div><h3 id="composition-api" tabindex="-1">Composition Api <a class="header-anchor" href="#composition-api" aria-label="Permalink to &quot;Composition Api&quot;">​</a></h3><p>composition api是一组API，允许我们使用导入的函数来编写Vue组件，而不是声明选项。它是一个统称，涵盖了以下API：</p><ul><li>反应性API，例如ref()和reactive()，允许我们直接创建反应性状态、计算状态和观察者。</li><li>生命周期钩子，例如onMounted()和onUnmounted()，允许我们以编程方式挂钩到组件生命周期。</li><li>依赖注入，即provide()和inject()，允许我们在使用反应性API时利用Vue的依赖注入系统。</li><li>暴露公共属性，即expose()，允许我们在组件外部访问组件实例的属性。</li><li></li></ul><p>composition api是Vue 3和Vue 2.7的内置特性。对于旧版本的Vue 2，可以使用官方维护的@vue/composition-api插件。在Vue 3中，它主要与单文件组件中的<code>&lt;script setup&gt;</code>语法一起使用。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { ref, onMounted } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// reactive state</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// functions that mutate state and trigger updates</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> increment</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  count.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// lifecycle hooks</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onMounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`The initial count is \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">value</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}.\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> @click</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;increment&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Count is: {{ count }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>composition api的主要优势是，它可以以可组合函数的形式实现干净、高效的逻辑复用。它解决了mixins的所有缺点，mixins是Options API的主要逻辑复用机制。</p><p>composition api还提供了更灵活的代码组织方式。许多用户喜欢我们使用Options API时默认编写有组织的代码：每个选项都有其所属的位置。然而，Options API在单个组件的逻辑超过一定的复杂度阈值时，就会带来严重的限制。这种限制在需要处理多个逻辑关注点的组件中尤为突出，这是我们在许多生产Vue 2应用中亲眼目睹的。</p><h2 id="如何使用和比较mixins和composition-api" tabindex="-1">如何使用和比较mixins和composition api <a class="header-anchor" href="#如何使用和比较mixins和composition-api" aria-label="Permalink to &quot;如何使用和比较mixins和composition api&quot;">​</a></h2><h3 id="mixins-1" tabindex="-1">mixins <a class="header-anchor" href="#mixins-1" aria-label="Permalink to &quot;mixins&quot;">​</a></h3><h4 id="mixins的用法" tabindex="-1">mixins的用法： <a class="header-anchor" href="#mixins的用法" aria-label="Permalink to &quot;mixins的用法：&quot;">​</a></h4><p>在组件选项中使用mixins数组，将一个或多个mixins对象混合到组件中。</p><p>mixins对象可以包含data、props、computed、methods、watch、生命周期钩子等任意组件选项。</p><p>当组件和mixins对象包含同名选项时，它们将以适当的方式进行合并。</p><p>例如，data对象会进行递归合并，同名钩子函数会合并为一个数组，同名方法会被组件覆盖。</p><p>可以使用全局混入，但要谨慎使用，因为它会影响每个创建的Vue实例，包括第三方组件。</p><p>可以使用自定义选项合并策略，向Vue.config.optionMergeStrategies添加一个函数。</p><h4 id="mixins的区别" tabindex="-1">mixins的区别： <a class="header-anchor" href="#mixins的区别" aria-label="Permalink to &quot;mixins的区别：&quot;">​</a></h4><ul><li><p>mixins是一种基于对象的代码复用方式，它会将mixins对象的属性和方法混合到组件实例中，这可能会导致命名冲突、数据来源不清晰、逻辑分散等问题。</p></li><li><p>mixins不利于类型推断，需要使用Vue.extend()或Vue.component()来声明组件类型，这会增加代码的冗余和复杂度。</p></li><li><p>mixins不支持\`\`tree shaking\`\`\`，即使没有使用mixins，也会将其打包到最终的构建中，这会增加构建的大小和运行时的开销。</p></li></ul><h3 id="composition-api-1" tabindex="-1">composition api <a class="header-anchor" href="#composition-api-1" aria-label="Permalink to &quot;composition api&quot;">​</a></h3><h4 id="composition-api的用法" tabindex="-1">composition api的用法： <a class="header-anchor" href="#composition-api的用法" aria-label="Permalink to &quot;composition api的用法：&quot;">​</a></h4><p>在组件中使用setup()函数作为composition api的入口点，它接收props和context两个参数。</p><p>在setup()函数中，可以使用反应性API(ref, relative)创建和返回反应性状态，也可以使用其他composition api，如生命周期钩子、依赖注入、暴露公共属性等。</p><p>在单文件组件中，可以使用<code>&lt;script setup&gt;</code>语法，以更简洁和优雅的方式编写composition api，不需要显式地返回状态或方法。</p><p>可以使用自定义的可组合函数，将相关的逻辑封装在一个函数中，然后在setup()函数中调用它们，实现逻辑的复用和组合。</p><h4 id="composition-api的区别" tabindex="-1">composition api的区别： <a class="header-anchor" href="#composition-api的区别" aria-label="Permalink to &quot;composition api的区别：&quot;">​</a></h4><ul><li><p>composition api是一种基于函数的代码复用方式，它不会修改组件实例，而是通过返回对象来暴露状态和方法，这可以避免命名冲突、数据来源不清晰、逻辑分散等问题。</p></li><li><p>composition api利于类型推断，可以使用TypeScript的类型注解来声明和检查状态和方法的类型，这可以提高代码的可读性和可维护性。</p></li><li><p>composition api支持树摇，只有使用的API才会被打包到最终的构建中，这可以减少构建的大小和运行时的开销。</p></li></ul><h2 id="mixins和composition-api的优缺点" tabindex="-1">mixins和composition api的优缺点 <a class="header-anchor" href="#mixins和composition-api的优缺点" aria-label="Permalink to &quot;mixins和composition api的优缺点&quot;">​</a></h2><h3 id="mixins的优点" tabindex="-1">mixins的优点： <a class="header-anchor" href="#mixins的优点" aria-label="Permalink to &quot;mixins的优点：&quot;">​</a></h3><ul><li>灵活地分发可复用功能</li><li>与Options API保持一致</li><li>兼容Vue 2和Vue 3</li></ul><h3 id="mixins的缺点" tabindex="-1">mixins的缺点： <a class="header-anchor" href="#mixins的缺点" aria-label="Permalink to &quot;mixins的缺点：&quot;">​</a></h3><ul><li>可能导致命名冲突、数据来源不清晰、逻辑分散等问题</li><li>不利于类型推断</li><li>不支持<code>tree shaking</code></li></ul><h3 id="composition-api的优点" tabindex="-1">composition api的优点： <a class="header-anchor" href="#composition-api的优点" aria-label="Permalink to &quot;composition api的优点：&quot;">​</a></h3><ul><li>实现干净、高效的逻辑复用和组合</li><li>利于类型推断</li><li>支持<code>tree shaking</code></li><li>提供更灵活的代码组织方式</li></ul><h3 id="composition-api的缺点" tabindex="-1">composition api的缺点： <a class="header-anchor" href="#composition-api的缺点" aria-label="Permalink to &quot;composition api的缺点：&quot;">​</a></h3><ul><li>需要学习新的API和语法</li><li>需要使用插件或Vue 3才能使用</li><li>与Options API不兼容</li></ul>`,40)]))}const c=s(t,[["render",l]]);export{d as __pageData,c as default};

import{_ as l,c as e,ag as i,o as r}from"./chunks/framework.BxW8Wou5.js";const _=JSON.parse('{"title":"14、加密技术和认证技术","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/软件设计师/第1章 - 计算机系统/14.加密技术和认证技术.md","filePath":"ruankao/软件设计师/第1章 - 计算机系统/14.加密技术和认证技术.md","lastUpdated":1760412047000}'),t={name:"ruankao/软件设计师/第1章 - 计算机系统/14.加密技术和认证技术.md"};function o(h,a,n,s,d,u){return r(),e("div",null,a[0]||(a[0]=[i('<h1 id="_14、加密技术和认证技术" tabindex="-1">14、加密技术和认证技术 <a class="header-anchor" href="#_14、加密技术和认证技术" aria-label="Permalink to &quot;14、加密技术和认证技术&quot;">​</a></h1><h2 id="加密技术-防窃听" tabindex="-1">加密技术（防窃听） <a class="header-anchor" href="#加密技术-防窃听" aria-label="Permalink to &quot;加密技术（防窃听）&quot;">​</a></h2><h3 id="对称加密-私有密钥加密" tabindex="-1">对称加密（私有密钥加密） <a class="header-anchor" href="#对称加密-私有密钥加密" aria-label="Permalink to &quot;对称加密（私有密钥加密）&quot;">​</a></h3><ul><li>只有一把密钥，加解密是同一把密钥</li><li>密钥分发有缺陷，无法保证只有收发方有密钥</li><li>加解密速度快</li><li>适合加密大量明文数据</li></ul><h4 id="种类" tabindex="-1">种类 <a class="header-anchor" href="#种类" aria-label="Permalink to &quot;种类&quot;">​</a></h4><ul><li>AES</li><li>RC5</li><li>DES</li></ul><h3 id="非对称加密-公开密钥加密" tabindex="-1">非对称加密（公开密钥加密） <a class="header-anchor" href="#非对称加密-公开密钥加密" aria-label="Permalink to &quot;非对称加密（公开密钥加密）&quot;">​</a></h3><ul><li>加密和解密不是同一把密钥，分别是公钥和私钥</li><li>用公钥加密，用私钥解密；用私钥加密就要用公钥解密</li><li>不能通过一把推出另一把</li><li>用接收方的公钥加密明文，<strong>可以实现防止窃听</strong></li><li>密钥分发没有缺陷</li><li>加解密速度慢</li></ul><h4 id="种类-1" tabindex="-1">种类 <a class="header-anchor" href="#种类-1" aria-label="Permalink to &quot;种类&quot;">​</a></h4><ul><li>RSA</li><li>DSA</li><li>ECC</li></ul><h3 id="混合加密" tabindex="-1">混合加密 <a class="header-anchor" href="#混合加密" aria-label="Permalink to &quot;混合加密&quot;">​</a></h3><p>先通过对称密钥加密大量的明文，然后将对称加密的密文和密钥通过非对称加密后传输</p><h2 id="认证技术-防篡改" tabindex="-1">认证技术（防篡改） <a class="header-anchor" href="#认证技术-防篡改" aria-label="Permalink to &quot;认证技术（防篡改）&quot;">​</a></h2><h3 id="摘要" tabindex="-1">摘要 <a class="header-anchor" href="#摘要" aria-label="Permalink to &quot;摘要&quot;">​</a></h3><p>将发送的明文进行 hash 算法后得到摘要放在密文后一起发送过去，与接收方解密后的明文进行相同的 hash 算法得到的摘要进行对比，如果一致则无篡改。</p><h3 id="数字签名" tabindex="-1">数字签名 <a class="header-anchor" href="#数字签名" aria-label="Permalink to &quot;数字签名&quot;">​</a></h3><ul><li>发送方用自己的私钥对摘要进行签名（加密）得到数字签名放在密文后一起发送过去</li><li>接收方用发送方的公钥对数字签名进行验证（解密）如果验证成功则没有被假冒且不可否认，否则为假冒发送</li></ul><h3 id="数字证书" tabindex="-1">数字证书 <a class="header-anchor" href="#数字证书" aria-label="Permalink to &quot;数字证书&quot;">​</a></h3><p>用户向 CA 机构申请数字证书，将个人信息和公钥发给 CA 机构，CA 机构颁给用户数字证书 <strong>数字证书用 CA 的私钥进行签名（加密）<strong>用</strong>CA 的公钥验证（解密）数字证书</strong>，得到用户的公钥</p>',19)]))}const b=l(t,[["render",o]]);export{_ as __pageData,b as default};

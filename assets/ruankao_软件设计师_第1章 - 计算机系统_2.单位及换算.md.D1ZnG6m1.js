import{_ as r,c as a,ag as o,o as l}from"./chunks/framework.BxW8Wou5.js";const c=JSON.parse('{"title":"2、单位及换算","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/软件设计师/第1章 - 计算机系统/2.单位及换算.md","filePath":"ruankao/软件设计师/第1章 - 计算机系统/2.单位及换算.md","lastUpdated":1760412047000}'),n={name:"ruankao/软件设计师/第1章 - 计算机系统/2.单位及换算.md"};function e(i,t,s,h,d,g){return l(),a("div",null,t[0]||(t[0]=[o('<h1 id="_2、单位及换算" tabindex="-1">2、单位及换算 <a class="header-anchor" href="#_2、单位及换算" aria-label="Permalink to &quot;2、单位及换算&quot;">​</a></h1><h2 id="例题" tabindex="-1">例题 <a class="header-anchor" href="#例题" aria-label="Permalink to &quot;例题&quot;">​</a></h2><h3 id="例题-1-2010-年下半年·存储器地址译码题" tabindex="-1">例题 1 2010 年下半年·存储器地址译码题 <a class="header-anchor" href="#例题-1-2010-年下半年·存储器地址译码题" aria-label="Permalink to &quot;例题 1 2010 年下半年·存储器地址译码题&quot;">​</a></h3><h4 id="题目" tabindex="-1">题目 <a class="header-anchor" href="#题目" aria-label="Permalink to &quot;题目&quot;">​</a></h4><p>采用 <strong>2K×4 位</strong> 的存储器芯片组成 <strong>16K×8 位</strong> 的存储器（地址单元为 <strong>0000H ～ 3FFFH</strong>，每个芯片的地址空间连续）。<br> 则地址单元 <strong>0B1FH</strong> 所在芯片的<strong>最小地址编号</strong>为（ ）。</p><ul><li>A. 0000H</li><li>B. 0800H</li><li>C. 2000H</li><li>D. 2800H</li></ul><h4 id="解析" tabindex="-1">解析 <a class="header-anchor" href="#解析" aria-label="Permalink to &quot;解析&quot;">​</a></h4><h5 id="数据规格换算" tabindex="-1">数据规格换算 <a class="header-anchor" href="#数据规格换算" aria-label="Permalink to &quot;数据规格换算&quot;">​</a></h5><ul><li><strong>2K×4</strong>：有 <strong>2K = 2048 = 2¹¹</strong> 个地址、每地址 4 bit。</li><li><strong>16K×8</strong>：有 <strong>16K = 16384 = 2¹⁴</strong> 个地址、每地址 8 bit。</li></ul><hr><h5 id="架构原则-先并后串" tabindex="-1">架构原则：先并后串 <a class="header-anchor" href="#架构原则-先并后串" aria-label="Permalink to &quot;架构原则：先并后串&quot;">​</a></h5><ol><li><strong>并位宽</strong>：两片 2K×4 并成 <strong>2K×8</strong>（地址线共用，数据线拼 8 位）。</li><li><strong>串容量</strong>：将“2K×8 块”再做片选级联，扩到 16K：<br> [ \\frac{16K}{2K} = 8 \\text{ 块} ] 因此共有 <strong>8 个 2K×8 的块</strong>（每块由两片 2K×4 组成）。</li></ol><blockquote><p><strong>块大小（BlockSize）= 单块容量 = 2K = 0x0800</strong></p></blockquote><hr><h5 id="地址线分配" tabindex="-1">地址线分配 <a class="header-anchor" href="#地址线分配" aria-label="Permalink to &quot;地址线分配&quot;">​</a></h5><ul><li><strong>片内地址线</strong>：A10 ～ A0（11 位） → 控制 2K 范围内单元。</li><li><strong>片选译码</strong>：A13 ～ A11（3 位） → 选择 8 个块之一（000 ～ 111）。</li><li>整机地址范围：0000H ～ 3FFFH（共 2¹⁴ 个地址）。</li></ul><hr><h5 id="分块起始地址表-步长-0x0800" tabindex="-1">分块起始地址表（步长 0x0800） <a class="header-anchor" href="#分块起始地址表-步长-0x0800" aria-label="Permalink to &quot;分块起始地址表（步长 0x0800）&quot;">​</a></h5><table tabindex="0"><thead><tr><th>块号（A13..A11）</th><th>起始地址</th></tr></thead><tbody><tr><td>000</td><td>0000H</td></tr><tr><td>001</td><td>0800H</td></tr><tr><td>010</td><td>1000H</td></tr><tr><td>011</td><td>1800H</td></tr><tr><td>100</td><td>2000H</td></tr><tr><td>101</td><td>2800H</td></tr><tr><td>110</td><td>3000H</td></tr><tr><td>111</td><td>3800H</td></tr></tbody></table><hr><h5 id="定位-0b1fh-所在块" tabindex="-1">定位 0B1FH 所在块 <a class="header-anchor" href="#定位-0b1fh-所在块" aria-label="Permalink to &quot;定位 0B1FH 所在块&quot;">​</a></h5><p>方法一（除法取整）： [ \\left\\lfloor \\frac{0x0B1F}{0x0800} \\right\\rfloor = \\left\\lfloor \\frac{2847}{2048} \\right\\rfloor = 1 ] → 在<strong>第 1 块</strong>（从 0 起计），其起始地址为<br> [ 1 \\times 0x0800 = \\mathbf{0x0800} ]</p><p>方法二（区间判断）： [ 0x0800 \\le 0x0B1F \\le 0x0FFF ] → 仍落在以 <strong>0x0800</strong> 为起点的块内。</p><blockquote><p>因此，0B1FH 所在芯片（块）的<strong>最小地址编号</strong>为 <strong>0800H</strong>。</p></blockquote><p><strong>答案：B. 0800H</strong></p><hr><h5 id="易错点与核验" tabindex="-1">易错点与核验 <a class="header-anchor" href="#易错点与核验" aria-label="Permalink to &quot;易错点与核验&quot;">​</a></h5><ul><li><strong>0000H</strong> 是第 0 块起始，仅当地址 &lt; 0x0800 时成立。</li><li><strong>2000H / 2800H</strong> 为第 4 / 第 5 块起始，远大于 0x0B1F。</li><li><strong>片数核对</strong>：每块 2 片（2K×4 并成 2K×8），共 8 块 → <strong>16 片</strong>。</li><li><strong>地址线数</strong>：16K 需 14 根（A13..A0），与“11 位片内 + 3 位片选”一致。</li></ul><hr><h5 id="通用解题模板-速记" tabindex="-1">通用解题模板（速记） <a class="header-anchor" href="#通用解题模板-速记" aria-label="Permalink to &quot;通用解题模板（速记）&quot;">​</a></h5><ol><li><strong>先并位宽，后串容量</strong>。</li><li><strong>块大小 = 单块地址数</strong>（本题 2K = 0x0800）。</li><li><strong>块起始地址 = 向下对齐到块边界</strong>：<br> [ \\text{start} = \\big\\lfloor \\frac{\\text{addr}}{\\text{BlockSize}} \\big\\rfloor \\times \\text{BlockSize} ]</li><li><strong>低位 → 片内地址，高位 → 片选译码</strong>。</li></ol><h3 id="_2012-年上半年·地址空间容量计算-完整解析与笔记" tabindex="-1">2012 年上半年·地址空间容量计算（完整解析与笔记） <a class="header-anchor" href="#_2012-年上半年·地址空间容量计算-完整解析与笔记" aria-label="Permalink to &quot;2012 年上半年·地址空间容量计算（完整解析与笔记）&quot;">​</a></h3><h4 id="题目-1" tabindex="-1">题目 <a class="header-anchor" href="#题目-1" aria-label="Permalink to &quot;题目&quot;">​</a></h4><p>内存单元按<strong>字节编址</strong>，地址 <strong>0000A000H ～ 0000BFFFH</strong>，共有（ ）个存储单元。</p><ul><li>A. 8192K</li><li>B. 1024K</li><li>C. 13K</li><li>D. 8K</li></ul><hr><h4 id="解题要点" tabindex="-1">解题要点 <a class="header-anchor" href="#解题要点" aria-label="Permalink to &quot;解题要点&quot;">​</a></h4><ul><li><strong>按字节编址</strong>：每个地址对应 <strong>1 字节</strong>，因此“存储单元数 = 字节数”。</li><li>地址范围是<strong>闭区间</strong>，总数公式： [ N = \\text{End} - \\text{Start} + 1 ]</li><li>将十六进制计算： [ \\text{End} = 0x0000BFFF,\\quad \\text{Start} = 0x0000A000 ] [ N = 0xBFFF - 0xA000 + 1 = 0x1FFF + 1 = 0x2000 = 8192 = \\mathbf{8K} ]</li></ul><p>也可快速判断：</p><ul><li>0xA000 ～ 0xAFFF：<strong>4K</strong></li><li>0xB000 ～ 0xBFFF：<strong>4K</strong></li><li>合计 <strong>8K 字节</strong>。</li></ul><hr><h4 id="答案" tabindex="-1">答案 <a class="header-anchor" href="#答案" aria-label="Permalink to &quot;答案&quot;">​</a></h4><p><strong>D. 8K</strong></p><hr><h4 id="易错点" tabindex="-1">易错点 <a class="header-anchor" href="#易错点" aria-label="Permalink to &quot;易错点&quot;">​</a></h4><ul><li>忽略“<strong>+1</strong>”（闭区间计算）。</li><li>把 <strong>K</strong> 当成 <strong>KB 的个数</strong>而非<strong>地址个数</strong>；本题按字节编址，<strong>8K 个地址 = 8KB</strong>。</li></ul>',46)]))}const x=r(n,[["render",e]]);export{c as __pageData,x as default};

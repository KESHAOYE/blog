import{_ as i,c as a,ag as t,o as l}from"./chunks/framework.BxW8Wou5.js";const d=JSON.parse('{"title":"1.解释下spa的原理 及 spa路由模式 及 SPA首屏优化 及部署后404问题","description":"","frontmatter":{},"headers":[],"relativePath":"interview/vue/1.解释下spa的原理 及 spa路由模式 及 SPA首屏优化.md","filePath":"interview/vue/1.解释下spa的原理 及 spa路由模式 及 SPA首屏优化.md","lastUpdated":1705937785000}'),h={name:"interview/vue/1.解释下spa的原理 及 spa路由模式 及 SPA首屏优化.md"};function p(n,s,e,k,r,E){return l(),a("div",null,s[0]||(s[0]=[t(`<h1 id="_1-解释下spa的原理-及-spa路由模式-及-spa首屏优化-及部署后404问题" tabindex="-1">1.解释下spa的原理 及 spa路由模式 及 SPA首屏优化 及部署后404问题 <a class="header-anchor" href="#_1-解释下spa的原理-及-spa路由模式-及-spa首屏优化-及部署后404问题" aria-label="Permalink to &quot;1.解释下spa的原理 及 spa路由模式 及 SPA首屏优化 及部署后404问题&quot;">​</a></h1><blockquote><p>参考：SPA 路由三部曲之核心原理 作者：京东设计中心JDC-杨小璐 <a href="https://mp.weixin.qq.com/s/I0Wgcy1jYvu5HIAW9BKQuQ" target="_blank" rel="noreferrer">链接</a></p></blockquote><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><p>SPA就是单页WEB应用。SPA离不开前端路由的支持。</p><h2 id="前端路由的发展" tabindex="-1">前端路由的发展 <a class="header-anchor" href="#前端路由的发展" aria-label="Permalink to &quot;前端路由的发展&quot;">​</a></h2><p>既然说到了前端路由，就要回溯下它的发展史</p><h3 id="后端路由" tabindex="-1">后端路由 <a class="header-anchor" href="#后端路由" aria-label="Permalink to &quot;后端路由&quot;">​</a></h3><p>早期，路由是后端的概念，页面渲染完全依靠服务器。用户进行页面切换的时候，浏览器发送不同的URL请求，通过解析不同的URL地址进行路由匹配，模板拼接好后将HTML字符串返回给前端，浏览器拿到HTML字符串后就交给浏览器解析展示，这也就是所谓的服务端渲染。</p><img src="https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenF9zvqVaK9WxL3zSb5DVZ1YLSJC9btYCkNyoISdNOeJ2CThTicObJDJVdlBiacj62DxUOu3rQ9kKtqoQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"><ul><li>优点：后端有完整的HTML代码，爬虫更容易获取信息，有利于SEO；对于客户端的资源占用更少</li><li>缺点：每跳转到不同的 URL都会重新访问服务器,给服务端增加压力;没有合理地利用缓存。</li></ul><h3 id="过渡方案ajax" tabindex="-1">过渡方案AJAX <a class="header-anchor" href="#过渡方案ajax" aria-label="Permalink to &quot;过渡方案AJAX&quot;">​</a></h3><p>AJAX是浏览器实现异步加载的一种技术方案。</p><h3 id="前端路由" tabindex="-1">前端路由 <a class="header-anchor" href="#前端路由" aria-label="Permalink to &quot;前端路由&quot;">​</a></h3><p>前端路由的特点就是在不完全刷新页面的情况下进行视图的切换，页面的URL变了，但并没有重新加载。 前端路由使页面渲染由服务器渲染变为了前端渲染，请求一个URL时，服务端返回的是一个空的HTML</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;!</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">DOCTYPE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> charset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;UTF-8&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Demo&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app.css&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stylesheet&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text/javascript&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>我们看到的页面是通过js渲染出来的</p><img src="https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenF9zvqVaK9WxL3zSb5DVZ1YLleWeCgY6FjRXdetmHRKEUDiaDE2ia3RIQc3BwYiacEbkPAyZVIE5RyudQ/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"><ul><li>优点：缓解服务端压力；</li><li>缺点: 渲染速度不如服务端渲染；不利于SEO优化</li></ul><h2 id="前端路由核心原理" tabindex="-1">前端路由核心原理 <a class="header-anchor" href="#前端路由核心原理" aria-label="Permalink to &quot;前端路由核心原理&quot;">​</a></h2><p>前端路由的展示方式有 2 种：</p><ul><li>带有hash的前端路由：地址栏 URL 中有 #，即 hash 值，不好看，但兼容性高。</li><li>不带hash的前端路由：地址栏 URL 中没有 #，好看，但部分浏览器不支持，还需要后端服务器支持。</li></ul><p><strong>原理：本质上就是通过监测URL的变化，截获URL地址，通过解析、匹配路由规则实现UI更新</strong></p><h3 id="hash" tabindex="-1">hash <a class="header-anchor" href="#hash" aria-label="Permalink to &quot;hash&quot;">​</a></h3><p>一个完整的URL包括：协议、域名、端口、虚拟目录、文件名、参数、锚。</p><img src="https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenF9zvqVaK9WxL3zSb5DVZ1YLE7h4HZYRWGMtpsIg7S3G6lz5rNfpQXzQFKDUKgdguq55C9ePaz2m0w/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"><p>hash值指的是URL地址中的锚部分，也就是#部分。hash也称为锚点，用来做页面定位的。</p><p>hash值更新有以下几个特点：</p><ul><li>hash值是网页的标志位，HTTP请求不包含锚部分，对后端没有影响</li><li>因为 HTTP 请求不包含锚部分，所以 hash 值改变时，不触发网页重载</li><li>改变 hash 值会改变浏览器的历史记录</li><li>改变 hash 值会触发 window.onhashchange() 事件</li></ul><p>改变hash值有以下几种方式</p><ul><li>通过a标签跳转</li><li>通过设置window.location.hash</li><li>浏览器前进（history.forword）后退(history.back)</li></ul><p><strong>hash模式路由就是利用onhashchange事件监听URL的变化，从而触发DOM操作来模拟页面跳转</strong></p><img src="https://mmbiz.qpic.cn/mmbiz_png/MrFJyDNenF9zvqVaK9WxL3zSb5DVZ1YLSHH00usG2TC2hdEIEJ60JmiboUG5icicTmuLb2Vyf5zptEtLabn582Liaw/640?wx_fmt=png&amp;tp=wxpic&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1"><h3 id="history" tabindex="-1">history <a class="header-anchor" href="#history" aria-label="Permalink to &quot;history&quot;">​</a></h3><p>浏览器有一个类似栈的历史记录，遵循先进后出的规则。URL的每次改变，包括hash值的改变都会在浏览器中形成一条历史记录。window对象通过history对象提供对浏览器历史记录的访问能力。</p><ul><li>history.lengh:出于安全考虑，History对象不允许未授权代码访问历史记录中其他页面的URLS，但可以通过history.length访问历史记录对象的长度。</li><li>history.back()：返回上一个历史记录，类似浏览器的后退按钮</li><li>history.forward(): 前进到下一个历史记录，类似浏览器前进按钮</li><li>history.go(n): 跳转到相应的访问记录，n &gt; 0，则前进，n &lt; 0，则后退</li></ul><p>为了配合单页应用的发展，HTML5对history API新增了两个方法</p><ul><li><p>pushState(state, title, URL)</p><ul><li>state: 用于存储该URL对应的状态对象，通过history.state获取</li><li>title：标题，不支持🈲</li><li>url：定义新的历史 URL 记录，需要注意，新的 URL 必须与当前 URL 同源，不能跨域。 <strong>TIPS：</strong> pushState 函数会向浏览器的历史记录中添加一条，history.length 的值会 +1，当前浏览器的 URL 变成了新的 URL。<strong>它仅仅将浏览器的 URL 变成了新的 URL，页面不会加载、刷新。</strong></li></ul></li><li><p>replaceState(state,title, URL) replaceState 的使用与 pushState 非常相似，都是改变当前的 URL，页面不刷新。<strong>区别在于 replaceState 是修改了当前的历史记录项而不是新建一个，history.length 的值保持不变。</strong></p></li></ul><h4 id="onpopstate" tabindex="-1">onpopstate() <a class="header-anchor" href="#onpopstate" aria-label="Permalink to &quot;onpopstate()&quot;">​</a></h4><p>通过pushState和replaceState改变的历史记录，点击浏览器的前进后退页面是没有反应的，为了配合上述两个API，HTML5还新增了一个事件，用于监听URL历史记录的改变：<code>window.onpopstate()</code></p><h2 id="spa首屏加载慢怎么解决" tabindex="-1">SPA首屏加载慢怎么解决 <a class="header-anchor" href="#spa首屏加载慢怎么解决" aria-label="Permalink to &quot;SPA首屏加载慢怎么解决&quot;">​</a></h2><h3 id="加载慢的原因" tabindex="-1">加载慢的原因 <a class="header-anchor" href="#加载慢的原因" aria-label="Permalink to &quot;加载慢的原因&quot;">​</a></h3><ul><li>网络延时原因</li><li>资源文件体积过大</li><li>资源重复发送请求去加载</li><li>加载脚本的时候，渲染被阻塞</li></ul><h3 id="解决方案" tabindex="-1">解决方案 <a class="header-anchor" href="#解决方案" aria-label="Permalink to &quot;解决方案&quot;">​</a></h3><ul><li><p>减小入口文件体积</p><p>常用的手段是路由懒加载，把不同的路由对应的组件分割成不同的代码块，待路由被请求的时候会被单独打包路由，使得入口文件变小，加载速度大大增加</p><p>在vue-router配置路由时，采用动态加载路由的形式</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  routes</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Blogs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Test&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    component: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./components/test.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span></code></pre></div><p>以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件</p></li><li><p>静态资源本地缓存</p><ul><li>采用HTTP缓存，设置Cache-Control、Last-Modified，Etag等</li><li>采用Service Worker离线缓存</li><li>合理利用localStorage</li></ul></li><li><p>UI框架按需加载（element等）</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { Button, Input, Pagination, Table, TableColumn, MessageBox } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;element-ui&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">use</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(Button)</span></span></code></pre></div></li><li><p>图片资源的压缩</p><p>使用雪碧图、在线字体图标等</p></li><li><p>组件重复打包</p><p>修改<code>webpack</code> <code>CommonsChunkPlugin</code>的配置</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 将使用3次以上的包抽离出来，避免重复加载</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  minChunks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span></code></pre></div></li><li><p>使用SSR</p><p>SSR（Server side ），也就是服务端渲染，组件或页面通过服务器生成html字符串，再发送到浏览器 从头搭建一个服务端渲染是很复杂的，vue应用建议使用Nuxt.js实现服务端渲染</p></li></ul>`,44)]))}const g=i(h,[["render",p]]);export{d as __pageData,g as default};

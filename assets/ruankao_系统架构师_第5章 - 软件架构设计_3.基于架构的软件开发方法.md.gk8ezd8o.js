import{_ as r,c as t,ag as o,o as e}from"./chunks/framework.BxW8Wou5.js";const n="/blog/picture/%E8%BD%AF%E8%80%83/%E5%9F%BA%E4%BA%8E%E6%9E%B6%E6%9E%84%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95%20-%20%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B.png",i="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E9%9C%80%E6%B1%82%E8%BF%87%E7%A8%8B.png",s="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%BF%87%E7%A8%8B.png",l="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B.png",E="/blog/picture/%E8%BD%AF%E8%80%83/%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8C%96%E8%BF%87%E7%A8%8B.png",m=JSON.parse('{"title":"3.基于架构的软件开发方法（ABSD）- 重视","description":"","frontmatter":{},"headers":[],"relativePath":"ruankao/系统架构师/第5章 - 软件架构设计/3.基于架构的软件开发方法.md","filePath":"ruankao/系统架构师/第5章 - 软件架构设计/3.基于架构的软件开发方法.md","lastUpdated":null}'),h={name:"ruankao/系统架构师/第5章 - 软件架构设计/3.基于架构的软件开发方法.md"};function p(c,a,_,g,d,B){return e(),t("div",null,a[0]||(a[0]=[o('<h1 id="_3-基于架构的软件开发方法-absd-重视" tabindex="-1">3.基于架构的软件开发方法（ABSD）- 重视 <a class="header-anchor" href="#_3-基于架构的软件开发方法-absd-重视" aria-label="Permalink to &quot;3.基于架构的软件开发方法（ABSD）- 重视&quot;">​</a></h1><h2 id="概念-选择题经常考" tabindex="-1">概念（选择题经常考） <a class="header-anchor" href="#概念-选择题经常考" aria-label="Permalink to &quot;概念（选择题经常考）&quot;">​</a></h2><ul><li>ABSD 方法是架构驱动，即强调由<strong>业务【商业】、质量和功能需求</strong>的组合驱动架构设计</li><li>ABSD 方法有三个基础 <ul><li>功能的分解（很多方法论都会这样做）。在功能的分解中，ABSD 方法使用已有的基于模块的内聚和耦合技术</li><li>通过选择架构风格来实现质量和业务需求</li><li>软件模版的使用</li></ul></li><li>视角和视图：从不同的视角来检查，所以会有不同的视图</li><li>用例用来<strong>捕获功能需求</strong>、特定场景【<strong>刺激、环境、响应</strong>】用来<strong>捕获质量需求（质量属性要求，如性能为度【用户请求的响应时间只能在 10ms 以内】）</strong></li></ul><h2 id="开发过程" tabindex="-1">开发过程 <a class="header-anchor" href="#开发过程" aria-label="Permalink to &quot;开发过程&quot;">​</a></h2><img src="'+n+'"><p>需求阶段： 架构需求 设计阶段：架构设计 设计后要生成对应文档：架构文档化 文档需要反复审核：架构复审 编码成可运行的：架构实现 持续优化改进：架构演化</p><p><strong>因为大量使用了构件化，所以可以很好的支持软件复用</strong></p><p>设计复审的过程中可能有问题，要打回重新设计，这就是<strong>递归细化</strong>， 0:N 代表可能递归多次</p><p>架构演化即不断优化的过程中 可能从架构需求开始不断演化优化，这也是<strong>递归细化</strong> 0:M 代表可能递归多次</p><p>通过不断细化，直到能得到<strong>软件构件和类</strong></p><h3 id="架构需求过程" tabindex="-1">架构需求过程 <a class="header-anchor" href="#架构需求过程" aria-label="Permalink to &quot;架构需求过程&quot;">​</a></h3><img src="'+i+'"><p>独特点： 给需求建立了库</p><h4 id="架构需求过程做了什么" tabindex="-1">架构需求过程做了什么？ <a class="header-anchor" href="#架构需求过程做了什么" aria-label="Permalink to &quot;架构需求过程做了什么？&quot;">​</a></h4><p>标识构件！</p><h3 id="架构设计过程" tabindex="-1">架构设计过程 <a class="header-anchor" href="#架构设计过程" aria-label="Permalink to &quot;架构设计过程&quot;">​</a></h3><img src="'+s+'"><h3 id="架构文档化" tabindex="-1">架构文档化 <a class="header-anchor" href="#架构文档化" aria-label="Permalink to &quot;架构文档化&quot;">​</a></h3><p>架构文档化过程的主要输出结果是<strong>架构规格说明</strong>和<strong>测试架构需求的质量设计说明书</strong>这两个文档</p><p>文档的<strong>完整性和质量</strong>是软件架构成功的关键因素</p><p><strong>关于文档的三大注意事项</strong>：</p><ul><li>文档要从使用者的角度编写</li><li>必须分发给所有与系统有关的开发人员</li><li>且必须保证<strong>开发者手上</strong>的文档是最新的</li></ul><h3 id="架构实现过程" tabindex="-1">架构实现过程 <a class="header-anchor" href="#架构实现过程" aria-label="Permalink to &quot;架构实现过程&quot;">​</a></h3><img src="'+l+'"><h3 id="架构演化过程-到了运维阶段" tabindex="-1">架构演化过程(到了运维阶段) <a class="header-anchor" href="#架构演化过程-到了运维阶段" aria-label="Permalink to &quot;架构演化过程(到了运维阶段)&quot;">​</a></h3><img src="'+E+'">',26)]))}const A=r(h,[["render",p]]);export{m as __pageData,A as default};
